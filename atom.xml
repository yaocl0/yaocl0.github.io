<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr_Yao的驿站</title>
  
  
  <link href="http://yaocl.cn/atom.xml" rel="self"/>
  
  <link href="http://yaocl.cn/"/>
  <updated>2023-06-27T05:47:55.470Z</updated>
  <id>http://yaocl.cn/</id>
  
  <author>
    <name>Mr_Yao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>以太坊概述</title>
    <link href="http://yaocl.cn/2023/06/27/27Ethereum/"/>
    <id>http://yaocl.cn/2023/06/27/27Ethereum/</id>
    <published>2023-06-27T05:31:22.000Z</published>
    <updated>2023-06-27T05:47:55.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以太坊基础知识"><a href="#以太坊基础知识" class="headerlink" title="以太坊基础知识"></a>以太坊基础知识</h1><h2 id="什么是以太坊"><a href="#什么是以太坊" class="headerlink" title="什么是以太坊"></a>什么是以太坊</h2><p>以太坊（Ethereum）是一个去中心化的开源的有智能合约功能的公共区块链平台。 以太坊的概念首次在 2013 至 2014 年间由程序员维塔利克·布特林（Vitalik Buterin）受比特币启发后提出，大意为“下一代加密货币与去中心化应用平台”，在 2014 年通过 ICO 众筹得以开始发展。以太坊亦被称为“第二代的区块链平台”，仅次于比特币。目前为止，以太坊是被使用最多的区块链平台。</p><p><img src="/2023/06/27/27Ethereum/1.png"></p><p>以太币（ETH 或 Ξ）是以太坊的原生加密货币，目前是市值第二高的加密货币，仅次于比特币。</p><h2 id="以太坊特点"><a href="#以太坊特点" class="headerlink" title="以太坊特点"></a>以太坊特点</h2><ol><li> 以太坊是 “世界计算机”，这代表它是一个开源的、全球分布的计算基础设施。</li><li> 执行称为智能合约（smart contract）的程序。</li><li> 使用区块链来同步和存储系统状态以及使用名为以太币（ether）的加密货币，以计量和约束执行资源成本。</li><li> 本质是一个基于交易的状态机 (transaction-based state machine)。</li><li> 以太坊平台使开发人员能够构建具有内置经济功能的强大去中心化应用程序（DApp）；在持续自我正常运行的同时，它还减少或消除了审查，第三方界面和交易对手风险。</li></ol><h2 id="以太坊的组成部分"><a href="#以太坊的组成部分" class="headerlink" title="以太坊的组成部分"></a>以太坊的组成部分</h2><p><img src="/2023/06/27/27Ethereum/2.png"></p><h3 id="P2P-网络"><a href="#P2P-网络" class="headerlink" title="P2P 网络"></a>P2P 网络</h3><p>以太坊在以太坊主网络上运行，该网络可在 TCP 端口 30303 上寻址，并运行一个名为 ÐΞVp2p 的协议。</p><h3 id="交易（Transaction）"><a href="#交易（Transaction）" class="headerlink" title="交易（Transaction）"></a>交易（Transaction）</h3><p>以太坊交易是网络消息，其中包括发送者（sender），接收者（receiver），值（value） 和数据的有效载荷（payload）。</p><h3 id="以太坊虚拟机（EVM）"><a href="#以太坊虚拟机（EVM）" class="headerlink" title="以太坊虚拟机（EVM）"></a>以太坊虚拟机（EVM）</h3><p>以太坊状态转换由以太坊虚拟机（EVM）处理，这是一个执行字节码（机器语言指令）的 基于堆栈的虚拟机。</p><h3 id="数据库（Blockchain）"><a href="#数据库（Blockchain）" class="headerlink" title="数据库（Blockchain）"></a>数据库（Blockchain）</h3><p>以太坊的区块链作为数据库（通常是 Google 的 LevelDB）本地存储在每个节点上，包含 序列化后的交易和系统状态。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>以太坊有几种可互操作的客户端软件实现，其中最突出的是 Go-Ethereum（Geth）和 Parity。</p><h2 id="以太坊中的重要概念"><a href="#以太坊中的重要概念" class="headerlink" title="以太坊中的重要概念"></a>以太坊中的重要概念</h2><h3 id="账户（Account）"><a href="#账户（Account）" class="headerlink" title="账户（Account）"></a>账户（Account）</h3><p>账户包含地址，余额和随机数，以及可选的存储和代码的对象。</p><ul><li>  普通账户（EOA），存储和代码均为空。</li><li>  合约账户（Contract），包含存储和代码。</li></ul><h3 id="地址（Address）"><a href="#地址（Address）" class="headerlink" title="地址（Address）"></a>地址（Address）</h3><p>一般来说，代表一个 EOA 或合约，它可以在区块链上接收或发送交易， 更具体地说，它是 ECDSA 公钥的 keccak 散列的最右边的 160 位</p><h3 id="交易（Transaction）-1"><a href="#交易（Transaction）-1" class="headerlink" title="交易（Transaction）"></a>交易（Transaction）</h3><ul><li>  可以发送以太币和信息。</li><li>  向合约发送的交易可以调用合约代码，并以信息数据为函数参数。</li><li>  向空用户发送信息，可以自动生成以信息为代码块的合约账户。</li></ul><h3 id="gas"><a href="#gas" class="headerlink" title="gas"></a>gas</h3><p>以太坊用于执行智能合约的虚拟燃料， 以太坊虚拟机使用核算机制来衡量 gas 的消耗量并限制计算资源的消耗</p><h2 id="以太坊的货币"><a href="#以太坊的货币" class="headerlink" title="以太坊的货币"></a>以太坊的货币</h2><p>以太坊的货币单位称为以太（ether），也可以表示为 ETH 或符号 Ξ</p><ul><li><p>以太币的发行规则：</p><p>  1 、挖矿前（Pre-mine，Genesis）</p><p>  2014 年 7 月 / 8 月间，为众筹大约发行了 7200 万以太币。这些币有的时候被称之为 “矿前”。众筹阶段之后，以太币每年的产量基本稳定，被限制不超过 7200 万的 25%。</p><p>  2、挖矿产出（Mining）</p><ul><li>  区块奖励（block reward）</li><li>  叔块奖励（uncle reward）</li><li>  叔块引用奖励（uncle referencing reward）</li></ul></li><li><p>以太币产量未来的变化</p><p>  以太坊出块机制从工作量证明（PoW）转换为股权证明（PoS）后，以太币的发行会有什么变化尚未有定论。股权证明机制将使用一个称为 Casper 的协议。在 Casper 协议下，以太币的发行率将大大低于工作量证明下幽灵（GHOST）协议下的发行率。</p></li></ul><h2 id="以太坊的挖矿产出"><a href="#以太坊的挖矿产出" class="headerlink" title="以太坊的挖矿产出"></a>以太坊的挖矿产出</h2><h3 id="区块奖励（Block-rewards）"><a href="#区块奖励（Block-rewards）" class="headerlink" title="区块奖励（Block rewards）"></a>区块奖励（Block rewards）</h3><p>每产生一个新区块就会有一笔固定的奖励给矿工，初始是 5 个以太币，现在是 3 个。</p><h3 id="叔块奖励（Uncle-rewards）"><a href="#叔块奖励（Uncle-rewards）" class="headerlink" title="叔块奖励（Uncle rewards）"></a>叔块奖励（Uncle rewards）</h3><p>有些区块被挖得稍晚一些，因此不能作为主区块链的组成部分。比特币称这类区块为 “孤块”，并且完全舍弃它们。但是，以太币称它们为 “叔块”（uncles），并且在之后的区块中，可以引用它们。如果叔块在之后的区块链中作为叔块被引用，每个叔块会为挖矿者产出区块奖励的 7/8。这被称之为叔块奖励。</p><h3 id="叔块引用奖励（Uncle-referencing-rewards）"><a href="#叔块引用奖励（Uncle-referencing-rewards）" class="headerlink" title="叔块引用奖励（Uncle referencing rewards）"></a>叔块引用奖励（Uncle referencing rewards）</h3><p>矿工每引用一个叔块，可以得到区块奖励的 1/32 作为奖励（最多引用两个叔块）。</p><h2 id="以太坊区块收入"><a href="#以太坊区块收入" class="headerlink" title="以太坊区块收入"></a>以太坊区块收入</h2><h3 id="普通区块收入"><a href="#普通区块收入" class="headerlink" title="普通区块收入"></a>普通区块收入</h3><ul><li>  固定奖励（挖矿奖励），每个普通区块都有。</li><li>  区块内包含的所有程序的 gas 花费的总和。</li><li>  如果普通区块引用了叔块，每引用一个叔块可以得到固定奖励的 1/32</li></ul><h3 id="叔块收入"><a href="#叔块收入" class="headerlink" title="叔块收入"></a>叔块收入</h3><p>叔块收入只有一项，就是叔块奖励，计算公式为： 叔块奖励 = (叔块高度 + 8 – 引用叔块的区块高度) * 普通区块奖励 / 8。</p><h2 id="以太坊和图灵完备"><a href="#以太坊和图灵完备" class="headerlink" title="以太坊和图灵完备"></a>以太坊和图灵完备</h2><p>1936 年，英国数学家艾伦 · 图灵（Alan Turing）创建了一个计算机的数学模型，它由一个控制器、一个读写头和一根无限长的工作带组成。纸带起着存储的作用，被分成一个个的小方格（可以看成磁带）；读写头能够读取纸带上的信息，以及将运算结果写进纸带；控制器则负责根据程序对搜集到的信息进行处理。在每个时刻，机器头都要从当前纸带上读入一个方格信息，然后结合自己的内部状态查找程序表，根据程序输出信息到纸带方格上，并转换自己的内部状态，然后进行移动纸带。这样的机器称为图灵机。</p><p><img src="/2023/06/27/27Ethereum/3.png"><br>如果一个系统可以模拟任何图灵机，它就被定义为 “图灵完备”（Turing Complete）的。 这种系统称为通用图灵机（UTM）</p><p>以太坊能够在称为以太坊虚拟机的状态机中执行存储程序，同时向内存读取和写入数据， 使其成为图灵完备系统，因此成为通用图灵机。考虑到有限存储器的限制，以太坊可以计 算任何可由任何图灵机计算的算法。简单来说，以太坊中支持循环语句，理论上可以运行 “无限循环” 的程序</p><h2 id="去中心化应用"><a href="#去中心化应用" class="headerlink" title="去中心化应用"></a>去中心化应用</h2><ul><li>  基于以太坊可以创建智能合约 (Smart Contract) 来构建去中心化应用 (Decentralized Application，简称为 DApp）</li><li>  以太坊的构想是成为 DApps 编程开发的平台</li><li>DApp 至少由以下组成：<ul><li>  区块链上的智能合约</li><li>  Web 前端用户界面</li></ul></li></ul><h2 id="以太坊应用"><a href="#以太坊应用" class="headerlink" title="以太坊应用"></a>以太坊应用</h2><ul><li>  基于以太坊创建新的加密货币（CryptoCurrency，这种能力是 2017 年各种 ICO 泛滥的技术动因）。</li><li>  基于以太坊创建域名注册系统、博彩系统。</li><li>  基于以太坊开发去中心化的游戏，比如 2017 年底红极一时的以太猫（CryptoKitties，最高单只猫售价高达 80W 美元)。</li></ul><h2 id="代币（Token）"><a href="#代币（Token）" class="headerlink" title="代币（Token）"></a>代币（Token）</h2><ul><li>  代币（token）也称作通证，本意为 “令牌”，代表有所有权的资产、货币、权限等在区块链上的抽象。</li><li>  可替代性通证（fungible token）：指的是基于区块链技术发行的，互相可以替代的，可以接近无限拆分的 token。</li><li>  非同质通证（non-fungible token）： 指的是基于区块链技术发行的，唯一的，不可替代的，大多数情况下不可拆分的 token，如加密猫（CryptoKitties）。</li></ul><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>  IP： Ethereum Improvement Proposals，以太坊改进建议。</li><li>  ERC：Ethereum Request for Comments 的缩写，以太坊征求意见。一些 EIP 被标记为 ERC，表示试图定义以太坊使用的特定标准的提议。</li><li>  EOA：External Owned Account，外部账户。由以太坊网络的人类用户创建的账户。</li><li>  Ethash：以太坊 1.0 的工作量证明算法。</li><li>  HD 钱包：使用分层确定性（HD protocol）密钥创建和转账协议（BIP32）的钱包。</li><li>  Keccak256：以太坊中使用的密码哈希函数。Keccak256 被标准化为 SHA-3。</li><li>  Nonce：在密码学中，术语 nonce 用于指代只能使用一次的值。以太坊使用两种类型的随机数，账户随机数和 POW 随机数。</li></ul><h1 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h1><h2 id="什么是以太坊客户端"><a href="#什么是以太坊客户端" class="headerlink" title="什么是以太坊客户端"></a>什么是以太坊客户端</h2><p>以太坊客户端是一个软件应用程序，它实现以太坊规范并通过 p2p 网络与其他以太坊客户端进行通信。如果不同的以太坊客户端符合参考规范和标准化通信协议，则可以进行相互操作。</p><p>以太坊是一个开源项目，由 “<a href="https://ethereum.github.io/yellowpaper/paper.pdf" title="以太坊黄皮书">以太坊黄皮书</a>” 正式规范定义。除了各种以太坊改进提案之外，此正式规范还定义了以太坊客户端的标准行为，因为有了明确的正式规范，以太网客户端有了许多独立开发的软件实现，它们之间又可以彼此交互。</p><p><img src="/2023/06/27/27Ethereum/4.png"></p><h2 id="基于以太坊规范的网络"><a href="#基于以太坊规范的网络" class="headerlink" title="基于以太坊规范的网络"></a>基于以太坊规范的网络</h2><p>存在各种基于以太坊规范的网络，这些网络基本符合 “以太坊黄皮书” 中定义的形式规范，但它们之间可能相互也可能不相互操作。</p><p>这些基于以太坊的网络中有：以太坊，以太坊经典，Ella，Expanse，Ubiq，Musicoin 等等。</p><p>虽然大多数在协议级别兼容，但这些网络通常具有特殊要求，以太坊客户端软件的维护人员、需要进行微小更改、以支持每个网络的功能或属性。</p><h2 id="以太坊的多种客户端"><a href="#以太坊的多种客户端" class="headerlink" title="以太坊的多种客户端"></a>以太坊的多种客户端</h2><ul><li>go-ethereum (Go)：<br>官方推荐，开发使用最多， Geth 是由以太坊基金会积极开发的 Go 语言实现，因此被认为是以太坊客户端的 “官方” 实现。通常，每个基于以太坊的区块链都有自己的 Geth 实现</li><li>parity (Rust)： 最轻便客户端，在历次以太坊网络攻击中表现卓越。</li><li>cpp-ethereum (C++)</li><li>pyethapp (python)</li><li>ethereumjs (javascript)</li><li>EthereumJ / Harmony (Java)</li></ul><h2 id="JSON-RPC"><a href="#JSON-RPC" class="headerlink" title="JSON-RPC"></a>JSON-RPC</h2><p>以太坊客户端提供了 API 和一组远程调用（RPC）命令，这些命令被编码为 JSON。这被称为 JSON-RPC API。本质上，JSON-RPC API 就是一个接口，允许编写的程序使用以太坊客户端作为网关，访问以太坊网络和链上数据。</p><p>通常，RPC 接口作为一个 HTTP 服务，端口设定为 8545。出于安全原因，默认情况下，它仅限于接受来自 localhost 的连接。</p><p>要访问 JSON-RPC API，可以使用编程语言编写的专用库，例如 JavaScript 的 web3.js，或者也可以手动构建 HTTP 请求并发送 / 接收 JSON 编码的请求。</p><h2 id="以太坊全节点"><a href="#以太坊全节点" class="headerlink" title="以太坊全节点"></a>以太坊全节点</h2><p>全节点是整个主链的一个副本，存储并维护链上的所有数据，可以随时验证新区块的合法性，运行全节点将耗费巨大的成本，包括硬件资源和带宽。</p><p>区块链的健康和扩展弹性，取决于具有许多独立操作和地理上分散的全节点。每个全节点都可以帮助其他新节点获取区块数据，并提供所有交易和合约的独立验证。</p><p>以太坊开发不需要在实时网络（主网）上运行的全节点。可以使用测试网络的节点来代替，也可以用本地私链，或者使用服务商提供的基于云的以太坊客户端，这些几乎都可以执行所有操作。</p><h2 id="远程客户端和轻节点"><a href="#远程客户端和轻节点" class="headerlink" title="远程客户端和轻节点"></a>远程客户端和轻节点</h2><p>远程客户端：<br>不存储区块链的本地副本或验证块和交易。这些客户端一般只提供钱包的功能，可以创建和广播交易。远程客户端可用于连接到现有网络，MetaMask 就是一个这样的客户端。</p><p>轻节点：<br>不保存链上的区块历史数据，只保存区块链当前的状态。轻节点可以对块和交易进行验证。</p><h3 id="全节点的优缺点"><a href="#全节点的优缺点" class="headerlink" title="全节点的优缺点"></a>全节点的优缺点</h3><ul><li>优点<ul><li>为以太坊网络的灵活性和抗审查性提供有力支持。</li><li>权威地验证所有交易。</li><li>可以直接与公共区块链上的任何合约交互。</li><li>可以离线查询区块链状态（帐户，合约等）。</li><li>可以直接把自己的合约部署到公共区块链中。</li></ul></li><li>缺点<ul><li>需要巨大的硬件和带宽资源，而且会不断增长。</li><li>第一次下载往往需要几天才能完全同步。</li><li>必须及时维护、升级并保持在线状态以同步区块。。</li></ul></li></ul><h3 id="公共测试网络节点的优缺点"><a href="#公共测试网络节点的优缺点" class="headerlink" title="公共测试网络节点的优缺点"></a>公共测试网络节点的优缺点</h3><ul><li>优点<ul><li>一个 testnet 节点需要同步和存储更少的数据，大约 10GB，具体取决于不同的网络</li><li>一个 testnet 节点一般可以在几个小时内完全同步</li><li>部署合约或进行交易只需要发送测试以太，可以从 “水龙头” 免费获得</li><li>测试网络是公共区块链，有许多其他用户和合约运行（区别于私链）</li></ul></li><li>缺点<ul><li>测试网络上使用测试以太，它没有价值。因此，无法测试交易对手的安全性，因为没有任何利害关系</li><li>测试网络上的测试无法涵盖所有的真实主网特性。例如，交易费用虽然是发送交易所必需的，但由于 gas 免费，因此 testnet 上往往不会考虑。而且一般来说，测试网络不会像主网那样经常拥堵</li></ul></li></ul><h3 id="本地私链的优缺点"><a href="#本地私链的优缺点" class="headerlink" title="本地私链的优缺点"></a>本地私链的优缺点</h3><ul><li>优点<ul><li>磁盘上几乎没有数据，也不同步别的数据，是一个完全 “干净” 的环境</li><li>无需获取测试以太，你可以任意分配以太，也可以随时自己挖矿获得</li><li>没有其他用户，也没有其他合约，没有任何外部干扰</li></ul></li><li>缺点<ul><li>没有其他用户意味与公链的行为不同。发送的交易并不存在空间或交易顺序的竞争</li><li>除自己之外没有矿工意味着挖矿更容易预测，因此无法测试公链上发生的某些情况</li><li>没有其他合约，意味着你必须部署要测试的所有内容</li></ul></li></ul><h2 id="用-Geth-搭建以太坊私链"><a href="#用-Geth-搭建以太坊私链" class="headerlink" title="用 Geth 搭建以太坊私链"></a>用 Geth 搭建以太坊私链</h2><p>一种是直接用源码安装，直接克隆 git 仓库，获取源代码的副本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ethereum/go-ethereum.git</span><br></pre></td></tr></table></figure><p>另一种是到官网直接下载对应系统的安装程序。</p><p>查看<code>geth version</code>，确保在真正运行之前安装正常。</p><h3 id="启动节点同步"><a href="#启动节点同步" class="headerlink" title="启动节点同步"></a>启动节点同步</h3><p>安装好了 Geth，可以尝试运行一下它。执行下面的命令，geth 就会开始同步区块，并存储在当前目录下。这里的<code>--syncmode fast</code>参数表示会以 “快速” 模式同步区块。在这种模式下，只会下载每个区块头和区块体，但不会执行验证所有的交易，直到所有区块同步完毕再去获取一个系统当前的状态。这样就节省了很多交易验证的时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth –datadir . --syncmode fast</span><br></pre></td></tr></table></figure><p>如果想同步测试网络的区块，可以用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --testnet --datadir . --syncmode fast</span><br></pre></td></tr></table></figure><p><code>--testnet</code>这个参数会告诉 geth 启动并连接到最新的测试网络，测试网络的区块和交易数量会明显少于主网，所以会更快一点。但即使是用快速模式同步测试网络，也会需要几个小时的时间。</p><h3 id="搭建自己的私链"><a href="#搭建自己的私链" class="headerlink" title="搭建自己的私链"></a>搭建自己的私链</h3><p>因为公共网络的区块数量太多，同步耗时太长，为了方便快速了解 Geth，可以试着用它来搭一个只属于自己的私链。</p><p>首先，需要创建网络的 “创世”（genesis）状态，这写在一个小小的 JSON 文件里（例如，将其命名为 genesis.json）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;chainId&quot;</span>: <span class="number">15</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;difficulty&quot;</span>: <span class="string">&quot;2000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;gasLimit&quot;</span>: <span class="string">&quot;2100000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;alloc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;7df9a875a174b3bc565e6424a0050ebc1b2d1d82&quot;</span>: &#123; <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;300000&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">&quot;f41c74c9ae680c1aa78f42e5647a62f353b7bdde&quot;</span>: &#123; <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;400000&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建一条以它作为创世块的区块链，可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir path/to/custom/data/folder init genesis.json</span><br></pre></td></tr></table></figure><p>在当前目录下运行 geth，就会启动这条私链，注意要将 networked 设置为与创世块配置里的 chainId 一致。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir path/to/custom/data/folder --networkid 15</span><br></pre></td></tr></table></figure><p>现在，节点正常启动，恭喜！已经成功启动了一条自己的私链。</p><h3 id="Geth-控制台命令"><a href="#Geth-控制台命令" class="headerlink" title="Geth 控制台命令"></a>Geth 控制台命令</h3><p>Geth Console 是一个交互式的 JavaScript 执行环境，里面内置了一些用来操作以太坊的 JavaScript 对象，可以直接调用这些对象来获取区块链上的相关信息。这些对象主要包括：</p><ul><li><p>eth：主要包含对区块链进行访问和交互相关的方法；</p></li><li><p>net：主要包含查看 p2p 网络状态的方法；</p></li><li><p>admin：主要包含与管理节点相关的方法；</p></li><li><p>miner：主要包含挖矿相关的一些方法；</p></li><li><p>personal：包含账户管理的方法；</p></li><li><p>txpool：包含查看交易内存池的方法；</p></li><li><p>web3：包含以上所有对象，还包含一些通用方法<br>常用命令有：</p></li><li><p>personal.newAccount()：创建账户；</p></li><li><p>personal.unlockAccount()：解锁账户；</p></li><li><p>eth.accounts：列出系统中的账户；</p></li><li><p>eth.getBalance()：查看账户余额，返回值的单位是 Wei；</p></li><li><p>eth.blockNumber：列出当前区块高度；</p></li><li><p>eth.getTransaction()：获取交易信息；</p></li><li><p>eth.getBlock()：获取区块信息；</p></li><li><p>miner.start()：开始挖矿；</p></li><li><p>miner.stop()：停止挖矿；</p></li><li><p>web3.fromWei()：Wei 换算成以太币；</p></li><li><p>web3.toWei()：以太币换算成 Wei；</p></li><li><p>txpool.status：交易池中的状态；</p></li></ul><h1 id="以太坊交易"><a href="#以太坊交易" class="headerlink" title="以太坊交易"></a>以太坊交易</h1><h2 id="以太币单位"><a href="#以太币单位" class="headerlink" title="以太币单位"></a>以太币单位</h2><p><img src="/2023/06/27/27Ethereum/5.png"></p><ul><li>  以太坊的货币单位称为以太，也称为 ETH 或符号 Ξ 。</li><li>  ether 被细分为更小的单位，直到可能的最小单位，称为 wei；1 ether = 10^18 wei 。</li><li>  以太的值总是在以太坊内部表示为以 wei 表示的无符号整数值。</li><li>  以太的各种单位都有一个使用国际单位制（SI）的科学名称，和一个口语名称。</li></ul><h2 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h2><h3 id="私钥、公钥和地址"><a href="#私钥、公钥和地址" class="headerlink" title="私钥、公钥和地址"></a>私钥、公钥和地址</h3><ul><li><p>  私钥（Private Key）：以太坊私钥是一个 256 位的随机数，用于发送以太的交易中创建签名来证明自己对资金的所有权</p></li><li><p>  公钥（Public Key）：公钥是由私钥通过椭圆曲线加密 secp256k1 算法单向生成的 512 位 （64 字节）数</p></li><li><p>  地址（Address）：地址是由公钥的 Keccak-256 单向哈希，取最后 20 个字节（160 位） 派生出来的标识符</p></li></ul><h3 id="以太坊账户类型"><a href="#以太坊账户类型" class="headerlink" title="以太坊账户类型"></a>以太坊账户类型</h3><p>以太坊账户分为外部账户 (Externally owned account, EOA)和 合约账户 (Contract accounts)。<br><img src="/2023/06/27/27Ethereum/6.png"></p><h4 id="EOA"><a href="#EOA" class="headerlink" title="EOA"></a>EOA</h4><p>外部账户：普通用户用私钥控制的账户</p><ul><li>  有对应的以太币余额</li><li>  可发送交易（转币或触发合约代码）</li><li>  由用户私钥控制</li><li>  没有关联代码</li></ul><h4 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h4><p>一种拥有合约代码的账户，它不属于任何人，也没有私钥与之对应。</p><ul><li>  有对应的以太币余额</li><li>  有关联代码</li><li>  由代码控制</li><li>  可通过交易或来自其它合约的调用消息来触发代码执行</li><li>  执行代码时可以操作自己的存储空间，也可以调用其它合约</li></ul><h2 id="以太坊钱包"><a href="#以太坊钱包" class="headerlink" title="以太坊钱包"></a>以太坊钱包</h2><p>以太坊钱包是我们进入以太坊系统的门户。它包含了私钥，可以代表我们创建和广播交易，常见得钱包有：</p><ul><li><p>  MetaMask：一个浏览器扩展钱包，可在浏览器中运行。下面例子中使用的是 MetaMask。</p></li><li><p>  Jaxx：一款多平台、多币种的钱包，可在各种操作系统上运行，包括 Android，iOS，Windows，Mac 和 Linux。</p></li><li><p>  MyEtherWallet（MEW）：一个基于 web 的钱包，可以在任何浏览器中运行。</p></li><li><p>  Emerald Wallet：旨在与 ETC 配合使用，但与其他基于以太坊的区块链兼容。</p></li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>以太坊中的交易是一个签名的数据包，由 EOA 发送到另一个账户，由以太坊网络传输，并被序列化后记录在以太坊区块链上，并且以太坊是一个全局单例状态机，交易是唯一可以触发状态更改或导致合约在 EVM 中执行的事物。</p><p>数据包里包含：</p><ul><li>  nonce：由发起人 EOA 发出的序列号，用于防止交易消息重播</li><li>  gas price：交易发起人愿意支付的 gas 单价（wei）</li><li>  start gas：交易发起人愿意支付的最大 gas 量</li><li>  to：目的以太坊地址</li><li>  value：要发送到目的地的以太数量</li><li>  data：可变长度二进制数据负载（payload）</li><li>  v,r,s：发起人 EOA 的 ECDSA 签名的三个组成部分</li></ul><p>交易消息的结构使用递归长度前缀（RLP）编码方案进行序列化，该方案专为在以太坊中准确和字节完美的数据序列化而创建。</p><h3 id="nonce"><a href="#nonce" class="headerlink" title="nonce"></a>nonce</h3><p>对于 EOA 账户，nonce 等于从这个账户地址发送的交易数。 对于合约账户，nonce 等于这个这个账户中创建的合约数。</p><p>nonce 值还用于防止错误计算账户余额。nonce 强制来自任何地址的交易按顺序处理，没有间隔，无论节点接收它们的顺序如何。使用 nonce 确保所有节点计算相同的余额和正确的序列交易，等同于用于防止比特币 “双重支付”（“重放攻击”）的机制。</p><h3 id="gas-1"><a href="#gas-1" class="headerlink" title="gas"></a>gas</h3><p>当交易或消息触发 EVM 运行时，每个指令都会在网络的每个节点上执行。对于每个执行的操作，都存在固定的成本，这个成本用一定量的 gas 表示。发起交易时，需要从执行代码的矿工那里用以太币购买 gas。</p><p>gas 与消耗的系统资源对应，这是具有自然成本的。因此在设计上 gas 和 ether 有意地解耦，消耗的 gas 数量代表了对资源的占用，而对应的交易费用则还跟 gas 对以太的单价有关。这两者是由自由市场调节的：gas 的价格实际上是由矿工决定的，他们可以拒绝处理 gas 价格低于最低限额的交易。我们不需要专门购买 gas ，只需将以太币添加到帐户即可，客户端在发送交易时会自动用以太币购买 gas。而以太币本身的价格通常由于市场力量而波动。</p><h3 id="gas-的计算"><a href="#gas-的计算" class="headerlink" title="gas 的计算"></a>gas 的计算</h3><p>在发起交易时发起人会先设置一个<code>gas limit</code>，代表消耗 gas 得上限，相当于押金。 实际支付的 gas 数量是执行过程中消耗的 gas （gasUsed），<code>gas limit</code> 中剩余的部分会返回给发送人。最终支付的 gas 费用是 gasUsed 对应的以太币费用，单价由设定的 gasPrice 而定。</p><p>最终支付费用 <code>totalCost = gasPrice * gasUsed</code> totalCost 会作为交易手续费（Tx fee）支付给矿工</p><h3 id="交易的接收者：to"><a href="#交易的接收者：to" class="headerlink" title="交易的接收者：to"></a>交易的接收者：to</h3><p><code>to</code>字段是一个 20 字节的以太坊地址，可以是 EOA 也可以是合约地址。</p><p>在以太坊中，任何 20 字节的值都被认为是有效的，以太坊没有做验证。如果 20 字节值没有对应的地址或者是不存在的合约，交易也是有效的，但是以太坊会销毁发送的以太，使其永远无法访问。</p><h3 id="交易的-value-和-data"><a href="#交易的-value-和-data" class="headerlink" title="交易的 value 和 data"></a>交易的 value 和 data</h3><p><code>value</code> 和 <code>data</code>是交易主要的“有效负载”，它们可以有 4 中组合。</p><ul><li>  仅有 value： 表示一笔以太的付款。</li><li>  仅有 data： 一般表示合约调用。</li><li>  同时有 value 和 data： 进行合约调用，同时忘合约中发送以太。</li><li>  既没有 value 也没有 data： 只是在浪费 gas，但它是有效的。</li></ul><h2 id="特殊交易：创建（部署）合约"><a href="#特殊交易：创建（部署）合约" class="headerlink" title="特殊交易：创建（部署）合约"></a>特殊交易：创建（部署）合约</h2><p>有一种特殊的交易，具有数据负载且没有 value，那就是一个创建新合约的交易。这个交易的<code>to</code>地址是一个特殊的地址，即零地址： 0x0。该地址既不代表 EOA 也不代表合约。它永远不会花费以太或发起交易，它仅用作目的地，具有特殊含义 “创建合约”。</p><p>虽然零地址仅用于合同注册，但它有时会收到来自各种地址的付款。 这种情况要么是偶然误操作，导致失去以太；要么是故意销毁以太。</p><h1 id="以太坊虚拟机-EVM"><a href="#以太坊虚拟机-EVM" class="headerlink" title="以太坊虚拟机 (EVM)"></a>以太坊虚拟机 (EVM)</h1><h2 id="以太坊虚拟机-EVM-简介"><a href="#以太坊虚拟机-EVM-简介" class="headerlink" title="以太坊虚拟机 (EVM) 简介"></a>以太坊虚拟机 (EVM) 简介</h2><p>以太坊虚拟机（ EVM ）是<code>智能合约</code>的运行环境， 作为区块验证协议的一部分，参与网络的每个节点都会运行 EVM。他们会检查正在验证的块中列出的交易，并运行由 EVM 中的交易触发的代码。</p><p>EVM 不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行的代码是无法访问网络、文件系统和其他进程的， 甚至智能合约之间的访问也是受限的。</p><p>合约以字节码的格式（EVM bytecode）存在于区块链上， 合约通常以高级语言（solidity）编写，通过 EVM 编译器编译为字节码，最终通过客户端上载部署到区块链网络中。</p><h2 id="EVM的工作原理"><a href="#EVM的工作原理" class="headerlink" title="EVM的工作原理"></a>EVM的工作原理</h2><h3 id="代码编译和部署"><a href="#代码编译和部署" class="headerlink" title="代码编译和部署"></a>代码编译和部署</h3><p>在以太坊上开发智能合约时，开发者使用Solidity等高级编程语言编写合约代码，并通过编译器将其转换为EVM能够理解和执行的字节码。</p><p>编译得到的字节码会被写入以太坊区块链，并分配一个唯一的合约地址。合约地址用于唯一标识合约在区块链上的存储位置。</p><h3 id="交易执行"><a href="#交易执行" class="headerlink" title="交易执行"></a>交易执行</h3><p>当一个合约交易被广播到以太坊网络时，EVM的节点会接收到该交易，并进行验证。验证通过后，EVM开始执行交易中的智能合约代码。</p><h3 id="EVM执行环境"><a href="#EVM执行环境" class="headerlink" title="EVM执行环境"></a>EVM执行环境</h3><p>EVM提供了一个独立的执行环境，每个交易都在自己的环境中执行。EVM的执行环境由以下几个组成部分：</p><p><img src="/2023/06/27/27Ethereum/7.png"></p><ul><li><p>栈（Stack）</p><p>  EVM 使用栈来存储和处理数据。栈是一种后进先出（LIFO）结构，用于执行指令时的操作数栈和返回值栈。</p><p>  存放部分局部值类型变量，几乎免费使用的内存，但有数量限制。</p></li><li><p>内存（Memory）</p><p>  EVM 提供了一块可扩展的内存区域，用于临时存储和操作数据。智能合约可以通过读写内存来进行复杂的计算和数据处理。</p><p>  每一次消息调用，合约会临时获取一块干净的内存空间，生命周期仅为整个方法执行期间，函数调用后回收，因为仅保存临时变量，故读写 gas 开销较小。</p></li><li><p>存储（Storage）<br>  EVM 提供了持久化的存储空间，用于永久保存合约的状态和数据。这是一个将 256 位字映射到 256 位字的 key-value 存储区，可以理解为合约的数据库，每个合约都有自己的存储空间。</p><p>  由于会永久保存合约状态变量，所以读写的 gas 开销也最大。</p></li><li><p>指令集（Instruction Set）</p><p>  EVM 定义了一套指令集，用于执行智能合约的操作和功能。指令集包括基本的算术运算、逻辑运算、存储读写操作等，也可以做到有条件和无条件跳转。所有的指令都是针对 “256 位的字（word）“这个基本的数据类型来进行操作。</p></li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>EVM的执行过程可以简单概括为以下几个步骤：</p><p>解析交易：EVM首先解析交易数据，提取出合约地址、调用参数等信息。</p><p>创建执行环境：EVM为该交易创建一个独立的执行环境，包括栈、存储和内存空间。</p><p>执行合约代码：EVM按照合约代码的指令顺序逐条执行，通过操作码来执行各种操作，如计算、存储、跳转等。</p><p>栈操作：EVM使用栈来保存和处理数据。在执行过程中，可以将数据压入栈顶、从栈顶弹出数据，进行栈上计算操作。</p><p>存储操作：EVM提供了持久化的存储空间Storage，可以读取和写入合约的状态和数据。通过存储操作码，可以将数据存储到存储空间或从存储空间中读取数据。</p><p>内存操作：EVM的临时内存空间可用于临时存储数据。通过内存操作码，可以将数据加载到内存中或从内存中读取数据。</p><p>跳转操作：EVM支持跳转操作，可以根据条件或无条件地改变代码执行的流程，实现条件判断、循环等控制结构。</p><p>异常处理：在执行过程中，如果遇到错误或异常情况，EVM会停止执行并回滚状态，确保合约的执行不会导致不一致的状态。</p><p>结束执行：当合约代码执行完毕或遇到返回指令时，EVM将结束执行，并将执行结果返回给调用者。</p><h1 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h1><h2 id="MetaMask-钱包"><a href="#MetaMask-钱包" class="headerlink" title="MetaMask 钱包"></a>MetaMask 钱包</h2><p>以太坊钱包是我们进入以太坊系统的门户。它包含了私钥，可以代表我们创建和广播交易。本文我们使用 MetaMask 钱包。 MetaMask 钱包可以在谷歌浏览器插件中安装。</p><h3 id="添加测试地址"><a href="#添加测试地址" class="headerlink" title="添加测试地址"></a>添加测试地址</h3><p>在以太坊主网上进行交易和执行智能合约需要支付 gas 费用，这些费用在开发和测试阶段可能会累积成相当大的开销。 因此，在开发和测试阶段一般都是使用太坊测试网络。这些测试网络通常提供免费的测试以太币。</p><p>这里有一些以太坊测试地址：<a href="https://talk.comunion.org/d/650-comunion-rpc-erc-20">https://talk.comunion.org/d/650-comunion-rpc-erc-20</a></p><p>本文选择 Avalanch 测试链：</p><pre><code>Avalanch Avalanch - Avalanch Testent网络名称：Avalanche Fuji Testnet新增 RPC URL：https://api.avax-test.network/ext/bc/C/rpcChain ID：43113货币符号：AVAX区块链浏览器 URL：https://cchain.explorer.avax-test.network水龙头地址：https://faucet.avax.network/</code></pre><h3 id="领取测试币"><a href="#领取测试币" class="headerlink" title="领取测试币"></a>领取测试币</h3><p>进入测试网络的水龙头地址<code>https://faucet.avax.network/</code>中，连接 MetaMask</p><p><img src="/2023/06/27/27Ethereum/8.png"></p><p>连接到 MetaMask 后，地址栏中会显示钱包的地址，点击<code>Request 2 AVAX</code>，等待交易完成，钱包地址中会有 2 AVAX 代币。<br><img src="/2023/06/27/27Ethereum/9.png"></p><h3 id="MateMask-中添加测试网络。"><a href="#MateMask-中添加测试网络。" class="headerlink" title="MateMask 中添加测试网络。"></a>MateMask 中添加测试网络。</h3><p>点击下面的<code>将子网添加到钱包</code>，并将钱包切换到测试网络。<br><img src="/2023/06/27/27Ethereum/10.png"></p><p>完成后，可以在钱包查看测试网中的账户信息<br><img src="/2023/06/27/27Ethereum/11.png"></p><h2 id="在-Remix-上构建简单的水龙头合约"><a href="#在-Remix-上构建简单的水龙头合约" class="headerlink" title="在 Remix 上构建简单的水龙头合约"></a>在 Remix 上构建简单的水龙头合约</h2><p>Remix 是一个在线用于构建和部署以太坊智能合约的开发工具和平台。它提供了一个用户友好的界面和功能强大的集成开发环境（IDE），帮助开发者更轻松地编写、测试和部署智能合约。</p><p>Remix 集成了 Solidity 编译器，可以将 Solidity 合约代码编译成 EVM（以太坊虚拟机）字节码。开发者可以使用 Remix 提供的编译器生成合约的字节码和 ABI（应用二进制接口），以便在以太坊上部署和调用合约。</p><p>Remix 的地址：<a href="https://remix.ethereum.org/">https://remix.ethereum.org</a></p><p><img src="/2023/06/27/27Ethereum/12.png"></p><h3 id="编写水龙头合约"><a href="#编写水龙头合约" class="headerlink" title="编写水龙头合约"></a>编写水龙头合约</h3><p>水龙头是一件相对简单的事情：它会向任何要求的地址发出以太。</p><p>在<code>contracts</code>目录下，新建一个<code>Faucet.sol</code>文件</p><p><img src="/2023/06/27/27Ethereum/13.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version of Solidity compiler this program was written for</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.19</span>;</span><br><span class="line"><span class="comment">// Our first contract is a faucet!</span></span><br><span class="line">contract Faucet &#123;</span><br><span class="line">    <span class="comment">// Give out ether to anyone who asks</span></span><br><span class="line">    <span class="function">function <span class="title">withdraw</span><span class="params">(uint withdraw_amount)</span> <span class="keyword">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Limit withdrawal amount</span></span><br><span class="line">        require(withdraw_amount &lt;= <span class="number">100000000000000000</span>);</span><br><span class="line">        <span class="comment">// Send the amount to the address that requested it</span></span><br><span class="line">        msg.sender.transfer(withdraw_amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Accept any incoming amount</span></span><br><span class="line">    function () <span class="keyword">public</span> payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>contract Faucet &#123;</code> ： 该行声明了一个合约对象，类似于其他面向对象语言中的类声明</p><p><code>function withdraw(uint withdraw_amount) public &#123;</code>： 该函数名为 withdraw，它接受一个名为 withdraw_amount 的无符号整数（uint）参数。它被声明为公共函数，这意味着它可以被其他合约调用</p><p><code>require(withdraw_amount &lt;= 100000000000000000);</code>： 该行设定提款限额。</p><p>使用内置的 Solidity 函数 require 来测试一个前提条件，即 withdraw_amount 小于或等于 100000000000000000 wei，这是 ether 的 基本单位，相当于 0.1 ether。</p><p>如果使用大于该数量的 withdraw_amount 调用 withdraw 函数，则此处的 require 函数将导致合约执行停止并因异常而失败</p><p><code>msg.sender.transfer(withdraw_amount);</code>： 该行是实际提现。</p><ul><li>  msg 对象：所有合约都可以访问的输入之一，它表示触发此合约执行的交易</li><li>  sender 属性：交易的发件人地址</li><li>  transfer 函数：是一个内置函数，它将以太从合约传递到调用它的地址。向后读，这意味着将以太转移到触发此合约执行的 msg 的发送者</li><li>  transfer 函数将金额作为其唯一参数。我们将 withdraw_amount 值作为参数传递给上面几行声明的 withdraw 函数</li></ul><p><code>function () public payable &#123;&#125;</code>： 此函数是所谓的 “回退” 或默认函数，如果触发合约的交易未命名合约中的任何已声明函数或任何函数或未包含数据，则调用此函数</p><h3 id="编译水龙头合约"><a href="#编译水龙头合约" class="headerlink" title="编译水龙头合约"></a>编译水龙头合约</h3><p>现在我们有了第一个示例合约，需要使用 Solidity 编译器将 Solidity 代码转换为 EVM 字节码，以便它可以由 EVM 执行。</p><p>在编译页面，首先要选择与代码中<code>pragma solidity ^0.4.19</code>相同的 solidity 版本。然后点击<code>Compile Faucet.sol</code>编译程序。</p><p><img src="/2023/06/27/27Ethereum/14.png"></p><h3 id="在区块链上创建合约"><a href="#在区块链上创建合约" class="headerlink" title="在区块链上创建合约"></a>在区块链上创建合约</h3><p>我们写了合约并把它编译成字节码。现在，我们需要在以太坊区块链上 “注册” 合约。我们将使用测试网来测试我们的合约。</p><p>在区块链上注册合约涉及创建一个特殊交易，其目的地是一个 “零地址”，也就是地址为：<code>0x0000000000000000000000000000000000000000</code>。零地址是一个特殊地址，告诉以太坊区块链我们想要注册合约。不过我们不需要手动输入这么多个 0，Remix IDE 将为我们处理所有这些，并将交易发送到 MetaMask，由钱包账户确认提交。</p><p>将运行环境关联到 MetaMask 上的测试链，然后点击 <code>Deploy</code>部署合约<br><img src="/2023/06/27/27Ethereum/15.png"></p><p>部署完成后会生成一个合约地址。同时包含了一些合约的其他信息，像合约地址的余额：<code>balance</code>，调用方法名<code>withdraw</code>等。<br><img src="/2023/06/27/27Ethereum/16.png"></p><h2 id="与合约交互"><a href="#与合约交互" class="headerlink" title="与合约交互"></a>与合约交互</h2><p>以太坊合约是控制资金的程序，它在称为 EVM 的虚拟机内运行。它们由特殊交易创建，该交易提交其字节码以记录在区块链上。一旦他们在区块链上创建，他们就有了一个以太坊地址，就像钱包一样。只要有人将某个交易发送到合约地址，就会导致合约在 EVM 中运行，并将该合约作为其输入。</p><p>发送到合约地址的交易可能包含 ether 或数据或两者。如果它们含有 ether，则将其 “存入” 合约余额。如果它们包含数据，则数据可以在合约中指定命名函数并调用它，将参数传递给函数</p><h3 id="资助合约"><a href="#资助合约" class="headerlink" title="资助合约"></a>资助合约</h3><p>目前，合约在其历史记录中只有一个交易：合约创建交易。</p><p>合约也还没有以太（零余额）。那是因为我们没有在创建交易中向合约发送任何以太。</p><p>我们可以给合约发一些以太，打开 MetaMask，给合约的地址发送以太，就像发送给其他任何以太坊地址一样。</p><p><img src="/2023/06/27/27Ethereum/17.png"></p><p>当交易完成后，再看合约的余额。</p><p><img src="/2023/06/27/27Ethereum/18.png"></p><h3 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h3><p>接下来，让我们从水龙头中提取一些资金。要提现，我们必须构造一个调用 <code>withdraw</code> 函数的交易，并将 withdraw_amount 参数传递给它。为了使事情变得简单，Remix 将为我们构建该交易，并由MetaMask发送交易。</p><p>我们输入要体现的金额，然后点击<code>withdraw</code>，表示调用withdraw方法。<br><img src="/2023/06/27/27Ethereum/19.png"></p><p>该交易导致合约在 EVM 内部运行，当 EVM 运行水龙头合约的提现功能时，首先它调用 require 函数并验证我们的金额小于或等于允许的最大提现 0.1 以太；然后它调用 transfer 函数向我们发送以太，运行转账功能会产生一个内部交易，从合约的余额中withdraw_amount的以太币存入我们的钱包地址；</p><p>当交易完成后，可以看到合约中的余额减少了。并且钱包中会多一条交易记录</p><p><img src="/2023/06/27/27Ethereum/20.png"></p><p><img src="/2023/06/27/27Ethereum/21.png"></p><p>我们可以点击<code>在区块浏览器上查看</code>，查看这条交易的详细信息。</p><p><img src="/2023/06/27/27Ethereum/22.png">迟到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;以太坊基础知识&quot;&gt;&lt;a href=&quot;#以太坊基础知识&quot; class=&quot;headerlink&quot; title=&quot;以太坊基础知识&quot;&gt;&lt;/a&gt;以太坊基础知识&lt;/h1&gt;&lt;h2 id=&quot;什么是以太坊&quot;&gt;&lt;a href=&quot;#什么是以太坊&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="以太坊" scheme="http://yaocl.cn/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
    <category term="以太坊" scheme="http://yaocl.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>SkyWalking，分布式链路追踪</title>
    <link href="http://yaocl.cn/2023/02/25/26SkyWalking/"/>
    <id>http://yaocl.cn/2023/02/25/26SkyWalking/</id>
    <published>2023-02-25T09:36:06.000Z</published>
    <updated>2023-05-22T01:00:59.056Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务的发展，软件架构也越来越复杂，为了适应海量用户高并发请求，系统中的组件也逐渐的变为分布式，单体服务变为微服务、缓存变为分布式缓存、组件通信变为分布式消息。</p><p>系统进行交互时，一个请求往往需要调用多个服务，当需要排查问题时，搞清楚服务之间的调用关系，服务与服务的调用顺序就变得重要起来。</p><p><img src="/2023/02/25/26SkyWalking/1.png"></p><h2 id="什么是分布式链路追踪"><a href="#什么是分布式链路追踪" class="headerlink" title="什么是分布式链路追踪"></a>什么是分布式链路追踪</h2><p>分布式链路追踪就是将一次分布式请求还原成调用链路，将一次分布式请求的调用情况集中展示，比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p><p><img src="/2023/02/25/26SkyWalking/2.png"></p><p>链路追踪最早可以追溯到谷歌的 Dapper 系统，但是 Dapper 链路追踪系统并没有开源，不过谷歌发表了一篇论文：《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，讲述了分布式链路追踪的理论和 Dapper 的设计思想，特别是微服务架构中链路追踪的概念、数据表示、埋点、传递、收集、存储与展示等技术细节。</p><p>Dapper 中有几个关键的技术点来表示链路的信息：Trace、Span、Annotations。</p><h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>Trace 表示一次请求经过所有服务的路径。用一个全局唯一的 traceid 来标识。</p><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>Span 用来表示父子关系，同一层级 parent id 相同，span id 不同，span id 从小到大表示请求的顺序。</p><h3 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h3><p>Annotations 用于用户自定义事件，用来辅助定位问题。<br>通常包含四个注解信息：</p><p>cs：Client Start，表示客户端发起请求；</p><p>sr：ServerReceived，表示服务端收到请求；</p><p>ss：Server Send，表示服务端完成处理，并将结果发送给客户端；</p><p>cr：ClientReceived，表示客户端获取到服务端返回信息；</p><p><img src="/2023/02/25/26SkyWalking/3.png"></p><h3 id="采样和存储"><a href="#采样和存储" class="headerlink" title="采样和存储"></a>采样和存储</h3><p>为了减少性能消耗，避免存储资源的浪费，dapper 并不会上报所有的 span 数据，而是使用采样的方式。举个例子，每秒有 1000 个请求访问系统，如果设置采样率为 1/1000，那么只会上报一个请求到存储端。</p><p>链路中的 span 数据经过收集和上报后会集中存储在一个地方，Dapper 使用了 BigTable 数据仓库，常用的存储还有 ElasticSearch, HBase, In-memory DB 等。</p><p>目前业界的链路追踪系统，如 Twitter 的 Zipkin，Uber 的 Jaeger，阿里的鹰眼，美团的 Mtrace 以及本文介绍的 SkyWalking，大多数都是受谷歌 Dapper 的启发。</p><h2 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h2><p>SkyWalking 是一个优秀的国产开源 APM（Application Performance Management） 组件，是一个对分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统。2015 年由个人吴晟开源 ， 2017 年加入 Apache 孵化器。</p><p>SkyWalking 支持 SpringBoot、SpringCloud、dubbo 集成，代码无侵入，通信方式采用 GRPC，性能较好，实现方式是 探针，支持告警，支持 JVM 监控，支持全局调用统计等等，功能较完善。</p><p>SkyWalking 的核心是数据分析和度量结果的存储平台，通过 HTTP 或 gRPC 方式向 SkyWalking Collecter 提交分析和度量数据。</p><h3 id="SkyWalking-架构"><a href="#SkyWalking-架构" class="headerlink" title="SkyWalking 架构"></a>SkyWalking 架构</h3><p><img src="/2023/02/25/26SkyWalking/4.png"></p><p>SkyWalking Collecter 对数据进行分析和聚合，存储到 Elasticsearch、H2、MySQL、TiDB 等其一即可，最后可以通过 SkyWalking UI 的可视化界面对最终的结果进行查看。</p><p>Skywalking 支持从多个来源和多种格式收集数据：多种语言的 Skywalking Agent 、Zipkin v1/v2 、Istio 勘测、Envoy 度量等数据格式。</p><p>在上面的架构图中我们需要关注的只有 SkyWalking Collecter、SkyWalking UI 和 存储设备，SkyWalking Collecter、SkyWalking UI 官方下载安装包内已包含，最终我们只需考虑存储设备即可。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>本文以 SkyWalking9.4.0 演示，SkyWalking 下载地址：<a href="http://skywalking.apache.org/downloads/">http://skywalking.apache.org/downloads/</a></p><p><img src="/2023/02/25/26SkyWalking/5.png"></p><p>以 Linux 为例。启动脚本在 bin/startup.sh。会启动两个服务:</p><p>1、 skywalking-oap-server 服务</p><p>skywalking-oap-server 服务启动后会暴露 11800 和 12800 两个端口，分别为收集监控数据的端口 11800 和接受前端请求的端口 12800，可以在 config/applicaiton.yml 修改端口，数据库存储等。默认使用 H2 数据库存储。</p><p><img src="/2023/02/25/26SkyWalking/6.png"></p><p>2、 skywalking-web-ui 服务</p><p>SkyWalking UI 界面的数据是通过请求 SkyWalking OAP 服务来获得。</p><p>skywalking-web-ui 服务会占用 8080 端口， 可以在 webapp/applicaiton.yml 修改端口。</p><p><img src="/2023/02/25/26SkyWalking/7.png"></p><p>启动成功之后，访问 Skywalking UI 界面：<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a></p><h3 id="项目集成"><a href="#项目集成" class="headerlink" title="项目集成"></a>项目集成</h3><p>监控 Java 项目，需要下载 Java 所需的探针 Skywalking Agent。</p><p><img src="/2023/02/25/26SkyWalking/8.png"></p><p>在 IDEA 中使用 SkyWalking， 配置 java 启动参数</p><p><img src="/2023/02/25/26SkyWalking/9.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 探针的位置</span></span><br><span class="line">-javaagent:/kywalking-agent所在目录/skywalking-agent/skywalking-agent.jar</span><br><span class="line"><span class="comment">//服务名称</span></span><br><span class="line">-Dskywalking.agent.service_name=system</span><br><span class="line"><span class="comment">//skywalking collector的地址</span></span><br><span class="line">-Dskywalking.collector.backend_service=<span class="number">192.168</span><span class="number">.68</span><span class="number">.28</span>:<span class="number">11800</span></span><br></pre></td></tr></table></figure><p>配置完，启动 Java 项目。</p><p><img src="/2023/02/25/26SkyWalking/10.png"></p><h3 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h3><p>链路拓扑</p><p><img src="/2023/02/25/26SkyWalking/11.png"></p><p>每个请求的调用链路</p><p><img src="/2023/02/25/26SkyWalking/12.png"></p><p>概览全局页</p><p><img src="/2023/02/25/26SkyWalking/13.png"></p>]]></content>
    
    
    <summary type="html">分布式链路追踪就是将一次分布式请求还原成调用链路，将一次分布式请求的调用情况集中展示，比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</summary>
    
    
    
    <category term="分布式链路追踪" scheme="http://yaocl.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    
    
    <category term="分布式链路追踪" scheme="http://yaocl.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>什么是DAPP</title>
    <link href="http://yaocl.cn/2023/01/13/25dapp/"/>
    <id>http://yaocl.cn/2023/01/13/25dapp/</id>
    <published>2023-01-13T07:36:06.000Z</published>
    <updated>2023-05-22T01:00:59.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DAPP（分布式应用），区块链新物种，去中心化-App"><a href="#DAPP（分布式应用），区块链新物种，去中心化-App" class="headerlink" title="DAPP（分布式应用），区块链新物种，去中心化 App"></a>DAPP（分布式应用），区块链新物种，去中心化 App</h2><p>简单来说，DAPP 和普通的 App 原理一样，除了他们是完全去中心化的，由类似以太坊网络本身自己的节点来运作的 DAPP，不依赖于任何中心化的服务器，DAPP 是去中心化的，可以完全自动地运行。</p><h3 id="1、DAPP（分布式应用）是什么"><a href="#1、DAPP（分布式应用）是什么" class="headerlink" title="1、DAPP（分布式应用）是什么"></a>1、DAPP（分布式应用）是什么</h3><p>DAPP 是 Decentralized Application 的缩写，中文叫分布式应用/去中心化应用，通常来说，不同的 DAPP 会采用不同的底层区块链开发平台和共识机制，或者自行发布代币（也可以使用基于相同区块链平台的通用代币）。</p><p><img src="/2023/01/13/25dapp/1.png"></p><p>符合以下 3 个条件的应用可以认为是一个 DAPP（分布式应用）：</p><p>运行在分布式网络上；</p><p>参与者信息被安全存储，隐私得到很好的保护；</p><p>通过网络节点去中心化操作。</p><p><img src="/2023/01/13/25dapp/2.png"></p><h3 id="2、DAPP-的四个特征"><a href="#2、DAPP-的四个特征" class="headerlink" title="2、DAPP 的四个特征"></a>2、DAPP 的四个特征</h3><p>DAPP 不同的底层区块链开发平台就好比手机的 IOS 系统和 Android 系统，是各 DAPP 的底层生态环境，DAPP 就是底层区块链平台生态上衍生的各种分布式应用，也是区块链世界中的基础服务提供方，DAPP 于区块链，就好比 APP 之于 IOS 和 Android。</p><p><img src="/2023/01/13/25dapp/3.png"></p><p>一个真正的 DAPP 应用，需要同时满足一下几个条件：</p><p>应用必须完全开源、自治，且没有一个实体控制着该应用超 51%Token。该应用必须能够根据用户的反馈及技术要求进行升级，且应用升级必须由大部分用户达成共识之后方可进行；</p><p>应用的数据必须加密后存储在公开的区块链上；</p><p>应用必须拥有 Token 机制（可用基于相同底层区块链平台的通用代币或自行发行新币），矿工或应用维护节点需要得到代币奖励；</p><p>应用代币的产生必须依据标准的加密算法，有价值的节点可以根据该算法获取应用的代币奖励。</p><h3 id="3、DAPP-应该制定类似宪法章程的智能合约"><a href="#3、DAPP-应该制定类似宪法章程的智能合约" class="headerlink" title="3、DAPP 应该制定类似宪法章程的智能合约"></a>3、DAPP 应该制定类似宪法章程的智能合约</h3><p>区块链的早期应用是货币交易、金融交易，随后是智能资产，包括房产、汽车等实物资产和知识产权、司法认证、公共档案等虚拟资产。</p><p>未来随着智能合约的发展，智能合约构建的组织如同现实商业社会一样的运行，这样形成的去中心化组织网络会变得极其复杂和自治，会出现各种形态：</p><p>Dapp（去中心化应用）<br>DAO（去中心化自治组织）<br>DAC（去中心化自治公司）<br>DAS（去中心化自治社会）<br>在没有人类干预的前提下，通过预先设定的业务规则自动运行。</p><p>一个简单的智能合约例子：2 个人打赌一场球赛，筹码会暂时保存到网络，球赛结束后，网络中预先设定的智能合约会校验在线结果，然后把钱打到赢家账户。</p><p><img src="/2023/01/13/25dapp/4.png"></p><h2 id="DAPP-优势"><a href="#DAPP-优势" class="headerlink" title="DAPP 优势"></a>DAPP 优势</h2><p>DAPP 用户体验由于区块链特有的数据确权、价值传递功能，可以消除很多影响用户体验、提升开发难度的因素：</p><p>（1）用户实名认证流程变更</p><p>DAPP 场景下，如果公链内支持数据共享，那么开发者只需要完成数据匹配，就可以从其他生态内的开发者处共享到用户实名资料，同时只需要支付 Token 即可；同时对用户而言，这也算是 POD（Proof of Data）挖矿模式，同样有收益，算是合作共赢；比如公信宝“布洛克城”。</p><p>（2）交易安全性提升</p><p>随着交易大爆炸的出现，交易效率的需求日渐提升；原来基于金融中介（例如银行、VISA 等）的交易处理方式效率低，信用生产成本高，为了降低这种风险，现在需要投入大量的风控成本进行审核但收效甚微。而基于 UTXO（Unspent Transaction Output）的区块链技术可以简单解决这个问题，而不需要对现有业务流程做任何变动升级，比如央行“数字票据交易平台”。</p><p>（3）行业生产关系的变更</p><p>区块链的数据确权、价值网络的两个属性可以变更现在的互联网生产关系，促使行业类应用出现，用户不用再为选择焦虑症发愁，典型的例子就是互联网视频；版权成本高昂导致腾讯、爱奇艺、搜狐只能付出极高的成本打击盗版、而用户追剧则需要在不同的平台购买 VIP 账号，如果基于区块链技术，剧集可以被版权方确权，用户不管通过任何渠道观看剧集，其支付的费用都可以 Token 化，然后由区块链基于价值网络分配给版权方、渠道方。在此生态内，盗版的问题被解决（比如 B 站 UGC 上传等），版权争夺成本下降，开发者专注于用户体验的提升，获取用户的方式也从版权壁垒变成社群运营，体验比拼，真正的互联网运营时代将会到来。例如当年的“火花电视”将各个平台的电视剧做到一站式观看，但是私自添加广告，影响版权方利益，最后被禁就是例子。</p><p>（4）项目运维成本降低</p><p>项目的运维成本往往高于开发成本，我们评估资源阈值的依据是预计最大流量，如果评估太低，则容易宕机，太高则浪费严重，例如：大多数产品应该都面临过运营活动带来的高并发问题，一次营销爆服务器的现象屡见不鲜，而添置服务器所带来的成本浪费则令人头疼，目前几个开发中的底层链（例如 EOS、Elastos）的资源分配模型基于用户持有 Token 的数量，这就意味着我们可以在某个活动开始前临时性购买 Token（资源），并在日常运维中将其释放（卖出），极大减少了运维成本。</p><p>（5）技术开发成本降低</p><p>目前项目开发通常会评估四个版本：iOS、Android、小程序、Web，理论上 DAPP 类似小程序，设计思想是无需安装，用完即走，所有的计算都在线上完成，本地禁止创建进程，系统自动创建或查找本地、周边、链内的其他微服务。</p><h2 id="DAPP-的劣势"><a href="#DAPP-的劣势" class="headerlink" title="DAPP 的劣势"></a>DAPP 的劣势</h2><p>（1）产品设计思路的颠覆</p><p>目前互联网产品设计思路是“小步快跑、高速迭代”，这个方式在纯 DAPP 应用中应该会出现较大问题。简单来说，现有的 APP 都基于自有服务器，重大问题迭代强行刷新版本即可，但 DAPP 基于分布式的区块链网络，一旦提交上线出现核心 bug 很难迭代。</p><p>拿 The DAO 来举个例子，The DAO 的核心漏洞如果是中心化处理，只需要下线更改 Bug 即可，但是以太坊却只能以硬分叉解决，这就是 DAPP 与现有 APP 设计思想的不同，在 MVP1.0 的调研阶段，一定要确认核心机制不出意外。</p><p>（2）公链处理效率低</p><p>目前成功落地的底层链都存在效率低、资源占用不合理问题，比特币的 5TPS、以太坊的 25TPS 跟 VISA 的 1300TPS 几乎没有可对比性。所以，目前公链并不适合商业化应用开发，如果借用其中几个技术（不涉及实时交易）倒是没有问题，比如积分交易、版权分享等。</p><p>（3）研发风险大</p><p>现在尚未出现普适性质的公链，就好像 PC 时代的 Windows、Mac OS；智能机时代的 iOS、Android。所以，基于某条公链的开发就要承担如果该公链被淘汰后血本无归的风险，好比当年的塞班开发者，或许跨链技术可以解决，但谁知道呢？综上所述，从互联网生态意义上来说，区块链技术是其底层结构的重要部分，未来所有的应用都需要考虑与其结合，也可能会有更多的全新应用模式出现。</p><h2 id="底线"><a href="#底线" class="headerlink" title="底线"></a>底线</h2><p>网上看到一句话说：DAPP 是技术进化的下一个合乎逻辑的步骤。我觉得有道理，区块链带来的人们的共识和数据的公开不可篡改，在这个基础上不依赖于人来执行的智能合约成为了可能，于是一切 App 的底层规则也就变了。</p>]]></content>
    
    
    <summary type="html">DAPP 和普通的 App 原理一样，除了他们是完全去中心化的，由类似以太坊网络本身自己的节点来运作的 DAPP，不依赖于任何中心化的服务器，DAPP 是去中心化的，可以完全自动地运行。</summary>
    
    
    
    <category term="web3" scheme="http://yaocl.cn/categories/web3/"/>
    
    
    <category term="web3" scheme="http://yaocl.cn/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务框架Seata</title>
    <link href="http://yaocl.cn/2022/12/19/24seata/"/>
    <id>http://yaocl.cn/2022/12/19/24seata/</id>
    <published>2022-12-19T06:33:18.000Z</published>
    <updated>2023-05-22T01:00:59.053Z</updated>
    
    <content type="html"><![CDATA[<p>分布式事务基础</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NjMwMTkzMw==&mid=2247484102&idx=1&sn=58aca57cc3c96f64af6c68e9944918d7&chksm=fcafc744cbd84e52da07629c679a9915ee9cb7ba5698aee5934429b19a95ce2a402c07dca756&token=1611733318&lang=zh_CN#rd">&lt;&lt;分布式事务基础理论&gt;&gt;</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NjMwMTkzMw==&mid=2247484148&idx=1&sn=2e5395cf06ce1fcf5fd52b1c4381ea49&chksm=fcafc776cbd84e600b244ba4040f1cdd8b4845bb3a1ec144497a41e4b65652468c621f9be8dd&token=1611733318&lang=zh_CN#rd">&lt;&lt;分布式事务解决方案&gt;&gt;</a></p><p>Seata 一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><h2 id="Seata-全局框架"><a href="#Seata-全局框架" class="headerlink" title="Seata 全局框架"></a>Seata 全局框架</h2><p>Seata 的设计思路是将一个分布式事务理解成一个全局事务下面挂了多个分支事务，而一个分支事务是一个满足 ACID 的本地事务，因此我们可以操作分布式事务像操作本地事务一样。</p><p>在 Seata 内部定义了三个模块来处理全局事务和分支事务：</p><ul><li>  Transaction Coordinator（TC) - 事务协调者: 维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。</li><li>  Transaction Manager (TM)-  事务管理器： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。</li><li>  Resource Manager (RM)  - 资源管理器： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</li></ul><p>Seata 提供的 AT、TCC、SAGA 和 XA 事务模式，都是基于这三个模块进行的。Seata 整体的执行步骤为：</p><ol><li> TM 向 TC 申请开启一个全局事务，TC 创建全局事务并返回一个唯一的 XID，XID 会在全局事务的上下文中传播。</li><li> RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务。</li><li> TM 向 TC 发起全局的提交或回滚。</li><li> TC 调度 XID 下的所有分支事务提交或回滚。</li></ol><p><img src="/2022/12/19/24seata/1.png"></p><h3 id="AT-模式"><a href="#AT-模式" class="headerlink" title="AT 模式"></a>AT 模式</h3><p>在<a href="https://mp.weixin.qq.com/s?__biz=MzU2NjMwMTkzMw==&mid=2247484148&idx=1&sn=2e5395cf06ce1fcf5fd52b1c4381ea49&chksm=fcafc776cbd84e600b244ba4040f1cdd8b4845bb3a1ec144497a41e4b65652468c621f9be8dd&token=1611733318&lang=zh_CN#rd">《分布式事务解决方案》</a>中介绍了常见的几种方案，总的来说主要分为两类：对业务无入侵和有入侵的方案。无入侵方案主要有基于数据库 XA 协议，虽然 XA 协议与业务代码解耦，但是它必须要求数据库对 XA 协议的支持，且 XA 协议会造成事务资源长时间得不到释放，锁定周期长，性能很差。有入侵的方案都需要通过在应用层做手脚，比如很出名的 TCC 方案，基于 TCC 也有很多成熟的框架，如 ByteTCC、tcc-transaction 等。</p><p>针对以上事务解决方案的痛点，Seata 提出了 AT 模式，<code>也是Seata默认的事务模式</code>。</p><p>AT 模式的实现原理是在数据源做了一层代理(DataSourceProxy)，在代理层中 Seata 加入了一些额外的逻辑，包括解析 SQL，把业务数据在更新前后的数据镜像组织成回滚日志，并将 undo log 日志插入 undo_log 表中，保证每条更新数据的业务 sql 都有对应的回滚日志存在。</p><p>AT 模式的执行过程</p><ul><li>  一阶段：</li></ul><p>Seata 拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成<code>before image</code>，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成<code>after image</code>，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。最后生成的<code>before image</code>和<code>after image</code>会保存到 undo log 表中</p><p><img src="/2022/12/19/24seata/2.png"></p><ul><li>  二阶段：</li></ul><p>如果是提交，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p><p><img src="/2022/12/19/24seata/3.png"></p><p>如果是回滚，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用<code>before image</code>还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</p><p><img src="/2022/12/19/24seata/4.png"></p><p>AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写业务 SQL，便能轻松使用分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Seata 分 TC、TM 和 RM 三个角色，TC（Server 端）为单独服务端部署，TM 和 RM（Client 端）由业务系统集成。</p><h3 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h3><ol><li> 下载启动包：<a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></li><li> 建表，主要的表有三个：</li></ol><ul><li><p>  全局事务：global_table</p></li><li><p>  分支事务：branch_table</p></li><li><p>全局锁：lock_table</p><p>  在 MySQL 中，创建一个名为 seata 的数据库实例。创建相关表的脚本在 <code>seata--&gt;script--&gt;server--&gt;db</code>目录下</p></li></ul><ol><li> 设置配置中心和注册中心</li></ol><ul><li><p>  搭建 nacos，具体的搭建过程自行查资料</p></li><li><p>配置中心： <code>seata--&gt;conf--&gt;application.yml</code> 修改 seata.config.type=”nacos”,在 <code>seata--&gt;conf--&gt;application.example.yml</code> 中 seata.config.nacos 下有相关的 nacos 配置，将其复制到 application.yml 下，并将 nacos 相关的数据配置完整。</p><p>  设置配置中心可以参考官网：<a href="https://seata.io/zh-cn/docs/user/configuration/nacos.html">https://seata.io/zh-cn/docs/user/configuration/nacos.html</a></p></li><li><p>  注册中心： <code>seata--&gt;conf--&gt;application.yml</code> 修改 seata.registry.type=”nacos”,在 <code>seata--&gt;conf--&gt;application.example.yml</code> 中 seata.registry.nacos 下有相关的 nacos 配置，将其复制到 application.yml 下，并将 nacos 相关的数据配置完整。</p></li></ul><ol><li><p>修改存储模式 store.mode<br> Server 端存储模式（store.mode）现有 file、db、redis 三种，file 模式无需改动，直接启动即可，下面专门讲下 db，因为 db 模式为高可用模式，全局事务会话信息通过 db 共享。<br> <code>seata--&gt;conf--&gt;application.yml</code>，修改 store.mode=”db”</p></li><li><p>修改数据库连接<br> <code>seata--&gt;conf--&gt;application.example.yml</code> 中附带额外配置，将其 db 相关配置复制至 application.yml，修改 store.db 相关属性。</p></li><li><p> 启动</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seata-server.sh -h 127.0.0.1 -p 8091 -m db</span><br></pre></td></tr></table></figure><h3 id="业务系统集成"><a href="#业务系统集成" class="headerlink" title="业务系统集成"></a>业务系统集成</h3><ol><li> 添加依赖，Seata 提供了不同的依赖包。可以根据项目自行选择，建议单选。</li></ol><ul><li>  依赖 seata-all</li><li>  依赖 seata-spring-boot-starter，支持 yml、properties 配置(.conf 可删除)，内部已依赖 seata-all</li><li>  依赖 spring-cloud-alibaba-seata，内部集成了 seata，并实现了 xid 传递</li></ul><ol><li> 在涉及到的服务的数据库中创建<code>undo_log</code>表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><ol><li> 初始化 GlobalTransactionScanner，如果引入<code>seata-spring-boot-starter</code>、<code>spring-cloud-starter-alibaba-seata</code>等 jar 会自动初始化，否则需要手动初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GlobalTransactionScanner <span class="title">globalTransactionScanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String applicationName = <span class="keyword">this</span>.applicationContext.getEnvironment().getProperty(<span class="string">&quot;spring.application.name&quot;</span>);</span><br><span class="line">    String txServiceGroup = <span class="keyword">this</span>.seataProperties.getTxServiceGroup();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(txServiceGroup)) &#123;</span><br><span class="line">        txServiceGroup = applicationName + <span class="string">&quot;-fescar-service-group&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.seataProperties.setTxServiceGroup(txServiceGroup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GlobalTransactionScanner(applicationName, txServiceGroup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li> 实现 xid 跨服务传递，如果是 Spring Cloud 项目，并引用了<code>spring-cloud-starter-alibaba-seata</code>jar，则已经自动实现了，否则需要参考源码 integration 文件夹下的各种 rpc 实现 module</li></ol><h4 id="业务使用"><a href="#业务使用" class="headerlink" title="业务使用"></a>业务使用</h4><p>1、以一个 Spring Cloud 项目为例，项目中有两个服务：订单服务和 库存服务。业务场景为创建订单的同时减库存。</p><p>在两个服务中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在每个业务服务下的数据库里添加<code>undo_log</code>表。</p><p>3、在每个业务服务下的配置文件中添加 seata 配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">default_tx_group</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata server 的服务名seata-server ，如果没有修改可以不配</span></span><br><span class="line">      <span class="attr">server-addr:</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment"># seata server 所在的nacos服务地址</span></span><br><span class="line">      <span class="attr">group :</span> <span class="string">DEFAULT_GROUP</span>  <span class="comment"># seata server 所在的组，默认就是SEATA_GROUP，没有改也可以不配</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">0d876b7d-4cfd-4860-bf81-8e5266c9375c</span> <span class="comment"># 自己seata注册中心namespace</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment"># seata server 所在的nacos服务地址</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">0d876b7d-4cfd-4860-bf81-8e5266c9375c</span> <span class="comment"># 自己seata注册中心namespace</span></span><br><span class="line">  <span class="attr">application-id:</span> <span class="string">seata-demo</span> <span class="comment">#</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>注意</code>：</p><ol><li> 这里的 group 要与 server 端配置的保持一致</li><li> tx-service-group 为事务群组，要部署同一套分布式事务的微服务要求事务群组要一致。可以在 nacos 的配置中查询 ：service.vgroupMapping.xxx。</li></ol><p><img src="/2022/12/19/24seata/5.png"></p><ol><li> 库存服务 <code>StockController</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/reduct&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduct</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//去库存</span></span><br><span class="line">    stockService.reduct(order.getProductId());</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在减库存的方法中模拟了一个业务异常<code>int a=1/0</code>，表示服务调用发生异常。</p><ol><li> 订单服务中创建调用库存服务的 Feign</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;stock-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StockApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/reduct&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">reduct</span><span class="params">(String productId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>订单服务<code>OrderService</code>，在需要开启全局事务的方法上添加<code>@GlobalTransactional</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Autowired</span><br><span class="line"><span class="keyword">private</span> StockApi stockApi;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line">    <span class="comment">// 减库存</span></span><br><span class="line">    stockApi.reduct(order.getProductId());</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用订单服务时，库存服务发生异常，可以判断发生异常后两个数据库中的数据是否回滚。</p><p>参考： <a href="https://seata.io/zh-cn/blog/seata-at-tcc-saga.html">https://seata.io/zh-cn/blog/seata-at-tcc-saga.html</a></p>]]></content>
    
    
    <summary type="html">Seata 的设计思路是将一个分布式事务理解成一个全局事务下面挂了多个分支事务，而一个分支事务是一个满足 ACID 的本地事务，因此我们可以操作分布式事务像操作本地事务一样。</summary>
    
    
    
    <category term="分布式事务" scheme="http://yaocl.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
    <category term="分布式事务" scheme="http://yaocl.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务基础</title>
    <link href="http://yaocl.cn/2022/11/23/23distributedTransaction/"/>
    <id>http://yaocl.cn/2022/11/23/23distributedTransaction/</id>
    <published>2022-11-23T02:27:40.000Z</published>
    <updated>2023-05-22T01:00:59.043Z</updated>
    
    <content type="html"><![CDATA[<p>事务是数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<br>事务有四个特性，习惯上被称为 ACID 特性：</p><ul><li>Atomicity(原子性)</li><li>Consistency(一致性)</li><li>Isolation(隔离性)</li><li>Durability(持久性)</li></ul><h2 id="本地事物"><a href="#本地事物" class="headerlink" title="本地事物"></a>本地事物</h2><p>在系统发展初期，单体应用对应一个数据库，整个服务操作只涉及一个数据库资源，通过数据库自带的事务很容易实现 ACID，这类基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)。</p><p><img src="/2022/11/23/23distributedTransaction/1.png"></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>随着互联网的发展，微服务架构大规模的普及，软件系统由原来的单体应用转变为分布式应用。分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。</p><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。比如在一个电商系统中，一条订单的生成涉及库存、订单、支付等不同的服务，不同的服务之间要么全成功、要么全失败，保证事务的 ACID 特性。</p><p><img src="/2022/11/23/23distributedTransaction/2.png"></p><p>本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p><p>在分布式系统中数据一致性又可以划分出多个一致性模型</p><ul><li><p>强一致性：任何一次读都能读到某个数据的最近一次写的数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任意时刻，所有节点中的数据是一样的。</p></li><li><p>弱一致性：数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。</p></li><li><p>最终一致性：不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，就是在一段时间后，节点间的数据会最终达到一致状态。</p></li></ul><p>在解决分布式事物的数据一致性问题上，产生了多个相关的理论。</p><h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><p>CAP 定理又被称作布鲁尔定理，是加州大学的计算机科学家布鲁尔在 2000 年提出的一个猜想。2002 年，麻省理工学院的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为分布式计算领域公认的一个定理。</p><ul><li>C : Consistency 一致性 , 所有实例节点同一时间看到是相同的数据</li><li>A : Availability 可用性 , 不管是否成功，确保每一个请求都能接收到响应</li><li>P : Partition tolerance 分区容错性 , 系统任意分区后，在网络故障时，仍能操作</li></ul><p>CAP 理论是指在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性、可用性、分区容错性者中的两个，另外一个必须被牺牲。</p><p>在真实的分布式环境下，如果我们选择了 CA（一致性 + 可用性） 而放弃了 P（分区容错性），那么当发生分区现象时，为了保证 C（一致性），系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A(可用性) 冲突了，因为 A（可用性）要求返回 no error 和 no timeout。因此虽然在 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来，必须选择 P（分区容错）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象。<br>也就说在真是环境下我们只能选择 CP（一致性 + 分区容错性） 或者 AP （可用性 + 分区容错性）架构，在一致性和可用性做折中选择。</p><p>虽然 CAP 理论告诉我们分布式系统只能选择 AP 或者 CP，但实际上并不是说整个系统只能选择 AP 或者 CP，在 CAP 理论落地实践时，我们需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP 还是 AP），而不是直接限定整个系统所有数据都是同一策略。</p><h2 id="BASE-理论–CAP-理论的延伸"><a href="#BASE-理论–CAP-理论的延伸" class="headerlink" title="BASE 理论–CAP 理论的延伸"></a>BASE 理论–CAP 理论的延伸</h2><p>由于在分布式系统中 C、A、P 三者都无法抛弃，但 CAP 定理限制三者无法同时满足，这种情况，我们会选择尽量靠近 CAP 定理，即尽量让 C、A、P 都满足，在此所趋下，出现了 BASE 定理。</p><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写。核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。</p><ul><li>BA：Basically Available 基本可用，分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</li><li>S：Soft State 软状态，允许系统存在中间状态，而该中间状态不会影响系统整体可用性。<br>分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。</li><li>E: Eventual Consistency 最终一致性， 系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li></ul><p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</p><p>BASE和ACID的区别与联系</p><ul><li>ACID是传统数据库常用的设计理念, 追求强一致性模型。</li><li>BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性</li></ul><p>ACID和BASE代表了两种截然相反的设计哲学。<br>总的来说，BASE 理论面向大型高可用可扩展的分布式系统，与ACID这种强一致性模型不同，常常是牺牲强一致性来获得可用性，并允许数据在一段时间是不一致的。虽然两者处于（一致性-可用性）分布图的两级，但两者并不是孤立的，对于分布式系统来说，往往依据业务的不同和使用的系统组件不同，而需要灵活的调整一致性要求，也因此，常常会组合使用ACID和BASE。</p><h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><p>不同于 ACID 的刚性事务，在分布式场景下基于 BASE 理论，就出现了柔性事务的概念。柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。并不是完全放弃了 ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐。</p><h2 id="XA-–强一致性"><a href="#XA-–强一致性" class="headerlink" title="XA –强一致性"></a>XA –强一致性</h2><p>由 Tuxedo 提出的 XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。XA 协议可以分为两部分，即事务管理器和本地资源管理器。</p><ul><li>事务管理器作为<code>协调者</code>，负责各个本地资源的提交和回滚。</li><li>资源管理器就是分布式事务的<code>参与者</code>.其中资源管理通常是数据库。</li></ul><p>基于 XA 协议的，发展出了二阶段提交协议（The two-phase commit protocol，2PC）和三阶段提交协议（Three-phase commit protocol，3PC）。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><p>将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。</p><p>0x1 准备阶段</p><ol><li> 协调者向所有参与者发送 CanCommit 操作请求，并等待参与者的响应。</li><li>参与者接收到请求后，会执行请求中的事务操作，将 undo 和 redo 信息记入事务日志中，但是这时并不提交事务。<br> <img src="/2022/11/23/23distributedTransaction/3.png"><br> 若不成功，则发送“No”消息，表示终止操作。当所有的参与者都返回了操作结果（Yes 或 No 消息）后，系统进入了提交阶段。<br> <img src="/2022/11/23/23distributedTransaction/4.png"></li></ol><p>0x2 提交阶段</p><p>协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令</p><ol><li><p>若协调者收到的都是“Yes”消息，则向参与者发送“DoCommit”消息，参与者会提交事务并释放资源，然后向协调者返回“Ack”消息。<br><img src="/2022/11/23/23distributedTransaction/5.png"></p></li><li><p>如果协调者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息，此时发送“Yes”的参与者会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送“Ack”消息；<br><img src="/2022/11/23/23distributedTransaction/6.png"></p></li></ol><ol start="3"><li>协调者接收到所有参与者的“Ack”消息，就意味着整个事务结束了。</li></ol><p>2PC 实现起来比较简单，但是实际项目中使用比较少，主要因为以下问题：</p><p>性能问题：所有参与节点都是事务阻塞型的，占用系统资源，容易导致性能瓶颈。</p><p>可靠性问题：如果协调者出现故障，参与者将一直处于锁定状态。</p><p>数据一致性问题：在提交阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</p><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>基于 2PC 基础上，3PC 对 2PC 进行了改进，引入了超时机制。同时将准备阶段拆分为 2 个阶段，多了一个 PreCommit 阶段。</p><p>3PC 可以划分为 CanCommit 阶段、PreCommit 阶段、DoCommit 阶段。</p><p>0x1 CanCommit 阶段</p><ol><li>协调者向所有参与者发送 “CanCommit” 请求，询问是否可以提交事务，并等待所有参与者答复。</li><li>参与者收到 “CanCommit” 请求之后，回复 “Yes”，表示可以顺利执行事务；否则回复 “No”。</li></ol><p><img src="/2022/11/23/23distributedTransaction/7.png"></p><p>0x2 PreCommit 阶段</p><p>协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作或中断事务。</p><p>如果参与者返回的回复情况全部是 Yes</p><ol><li>协调者向所有参与者发送 “PreCommit” 请求，参与者进入到预提交阶段。</li><li>参与者收到 “PreCommit” 请求后，执行事务操作，并将 undo 和 redo 信息记入事务日志中，但这时并不提交事务。</li><li>参与者向协调者反馈执行成功 “Yes” 或失败响应 “No”。</li></ol><p><img src="/2022/11/23/23distributedTransaction/8.png"></p><p>如果参与者返回的回复情况中包含 No，说明有一个事务执行失败。</p><ol><li>协调者向所有参与者发送 “Abort”请求</li><li>参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的中断操作。</li></ol><p>0x3 DoCommit 阶段</p><p>协调者根据参与者的回复情况，来决定是否可以进行 DoCommit 操作 或 中断事务。</p><p>如果参与者返回的回复情况全部是 YES</p><ol><li>协调者向所有参与者发送 “DoCommit” 消息。</li><li>参与者接收到 “DoCommit” 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。</li><li>参与者提交完事务之后，向协调者发送 “Ack” 响应</li><li>协调者接收到所有参与者的 “Ack” 响应之后，完成事务。</li></ol><p><img src="/2022/11/23/23distributedTransaction/9.png"></p><p>如果参与者返回的回复情况中包含 No，说明有一个事务执行失败。</p><ol><li>协调者向所有参与者发送 “Abort” 请求。</li><li>参与者接收到 “Abort” 消息之后，利用其在 “PreCommit” 阶段记录的 undo 信息执行事务的回滚操作，并释放所有锁住的资源。</li><li>参与者完成事务回滚之后，向协调者发送 “Ack” 消息。</li><li>协调者接收到参与者反馈的 “Ack” 消息之后，执行事务的中断，并结束事务。</li></ol><p>相比二阶段提交，三阶段降低了阻塞范围，在等待超时后协调者或参与者会中断事务，避免了协调者单点问题。DoCommit 阶段中协调者出现问题时，参与者会继续提交事务。</p><p>但是数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 DoCommit 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p><h2 id="TCC-–最终一致性"><a href="#TCC-–最终一致性" class="headerlink" title="TCC –最终一致性"></a>TCC –最终一致性</h2><p>TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p><p>TCC 是服务化的二阶段编程模型， 针对每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个服务都需要实现 Try、Confirm、Cancel 三个操作，第一阶段由业务代码编排来调用 Try 接口进行资源预留，当所有参与者的 Try 接口都成功了，事务协调者提交事务，并调用参与者的 Confirm 接口真正提交业务操作，否则调用每个参与者的 Cancel 接口回滚事务，并且由于 Confirm 或者 Cancel 有可能会重试，因此对应的部分需要支持幂等。</p><ul><li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</li><li>Confirm 阶段： 确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性</li><li>Cancel 阶段： 取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</li></ul><p><img src="/2022/11/23/23distributedTransaction/10.png"></p><p>TCC 事务机制相比于上面介绍的 XA，解决了其几个缺点：</p><ol><li>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</li><li>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</li><li>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性</li></ol><p>但是TCC中Try、Confirm、Cancel 的操作需要业务来实现，耦合度过高。</p><h2 id="本地消息表-–最终一致性"><a href="#本地消息表-–最终一致性" class="headerlink" title="本地消息表 –最终一致性"></a>本地消息表 –最终一致性</h2><p>本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。核心思路是将分布式事务拆分成本地事务进行处理。 本地事物表方案可以将事务分为事务主动方和事物被动方。</p><ul><li>事务主动方: 分布式事务最先开始处理的事务方</li><li>事务被动方: 在事务主动方之后处理的业务内的其他事务</li></ul><p>事务的主动方需要<code>额外新建事务消息表</code>，用于记录分布式事务的消息的发生、处理状态。整个业务流程：</p><ol><li>事务主动方在本地事务中处理业务更新操作和写消息表操作。</li><li>事务主动方通过消息中间件，通知事务被动方处理事务。</li><li>事务被动方通过消息中间件，通知事务主动方事务已处理的消息</li></ol><p><img src="/2022/11/23/23distributedTransaction/11.png"></p><p>本地消息表实现的条件：</p><ul><li>消费者与生成者的接口都要支持幂等</li><li>生产者需要额外的创建消息表</li><li>需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作</li></ul><p>容错机制：</p><ul><li>步骤 1 失败时，事务直接回滚</li><li>步骤 2、3 写 mq 与消费 mq 失败会进行重试</li><li>步骤 3 业务失败事务被动方向事务主动方发起事务回滚操作</li></ul><h2 id="MQ-事务-–最终一致性"><a href="#MQ-事务-–最终一致性" class="headerlink" title="MQ 事务 –最终一致性"></a>MQ 事务 –最终一致性</h2><p>有些 MQ 的实现支持事务，比如 RocketMQ ，基于 MQ 的分布式事务方案其实是对本地消息表的封装。以 RocketMQ 为例介绍 MQ 的分布式事务方案。</p><ol><li>发送方向 MQ 服务端(MQ Server)发送 half 消息。这个 half 消息与普通消息的区别在于，在事物提交之前，这个消息对订阅方来说是不可见的，订阅方不会消费这个消息。</li><li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。</li><li>发送方开始执行本地事务逻辑。</li><li>如果事务提交成功，将会发送确认消息（commit 或是 rollback）至 MQ Server。</li><li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除half消息，订阅方将不会接受该消息。</li></ol><p><img src="/2022/11/23/23distributedTransaction/12.png"></p><p>异常情况 1：如果发送方发送 commit 或 rollback 消息失败，未到达消息集群</p><ul><li>MQ Server 会发起消息回查</li><li>发送方收到回查消息后，会检查本地事务的执行结果</li><li>根据本地事务的执行结果重新发送 commit 或 rollback 消息</li><li>MQ Server 根据接收到的消息（commit 或 rollback）判断消息是否可消费或直接删除</li></ul><p>异常情况 2：接收方消费失败或消费超时</p><ul><li>一直重试消费，直到事务订阅方消费消息成功，整个过程可能会导致重复消费问题，所以业务逻辑需要保证幂等性</li></ul><p>异常情况 3：消息已消费，但接收方业务处理失败</p><ul><li>通过 MQ Server 通知发送方进行补偿或事务回滚</li></ul><h2 id="Saga-事务-–最终一致性"><a href="#Saga-事务-–最终一致性" class="headerlink" title="Saga 事务 –最终一致性"></a>Saga 事务 –最终一致性</h2><p>Saga 事务源于 1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文，Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p><p>Saga 事务基本协议如下：</p><p>每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。<br>每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。</p><p>Saga 的执行顺序有两种：</p><ul><li>T1, T2, T3, …, Tn</li><li>T1, T2, …, Tj, Cj,…, C2, C1，其中 0 &lt; j &lt; n</li></ul><p>Saga 定义了两种恢复策略：</p><ul><li>向前恢复(forward recovery)<br>适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中 j 是发生错误的子事务(sub-transaction)。该情况下不需要 Ci。</li></ul><p><img src="/2022/11/23/23distributedTransaction/13.png"></p><ul><li>向后恢复(backward recovery)<br>如果任一子事务失败，补偿所有已完成的事务。即上面提到的第二种执行顺序，其中 j 是发生错误的 sub-transaction，这种做法的效果是撤销掉之前所有成功的 sub-transation，使得整个 Saga 的执行结果撤销。</li></ul><p><img src="/2022/11/23/23distributedTransaction/14.png"></p><p>Saga 事务常见的有两种不同的实现方式：</p><ol><li>命令协调(Order Orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序</li></ol><p><img src="/2022/11/23/23distributedTransaction/15.png"></p><ol start="2"><li>事件编排 (Event Choreography)：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。<br>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。<br>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</li></ol><p><img src="/2022/11/23/23distributedTransaction/16.png"></p>]]></content>
    
    
    <summary type="html">分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</summary>
    
    
    
    <category term="分布式事务" scheme="http://yaocl.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
    <category term="分布式事务" scheme="http://yaocl.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>智能合约</title>
    <link href="http://yaocl.cn/2022/10/10/22smartContract/"/>
    <id>http://yaocl.cn/2022/10/10/22smartContract/</id>
    <published>2022-10-10T09:25:14.000Z</published>
    <updated>2023-05-22T01:00:59.043Z</updated>
    
    <content type="html"><![CDATA[<p>接触区块链的，经常会听到智能合约这个词，那什么是智能合约？今天就来了解了解。</p><h2 id="比特币引领区块链，以太坊复活智能合约"><a href="#比特币引领区块链，以太坊复活智能合约" class="headerlink" title="比特币引领区块链，以太坊复活智能合约"></a>比特币引领区块链，以太坊复活智能合约</h2><p>1994 年，计算机科学家和密码学家 Nick Szabo 首次提出“智能合约”概念，它早于区块链概念的诞生，几乎与互联网同龄。</p><p><img src="/2022/10/10/22smartContract/1.png"></p><p>Szabo 描述了什么是“以数字形式指定的一系列承诺，包括各方履行这些承诺的协议”。虽然有它的好处，但智能合约的想法一直未取得进展——一个重要原因是因为缺乏能够支持可编程合约的数字系统和技术。</p><p>直到 2008 年，第一个加密货币比特币出现，同时引入了现代区块链技术。区块链最初是以比特币的底层技术出现的，但是智能合约在 2008 年依然无法融入比特币区块链网络。五年后，以太坊创始人 Vitalik Buterin 发布了白皮书《以太坊：下一代智能合约和去中心化应用平台》， 作为首个支持“图灵完备”智能合约的区块链网络，以太坊掀开了以智能合约为代表的区块链 2.0 时代的序章。从此，涌现出了各种不同形式的智能合约，其中以太坊智能合约使用最广。</p><p><img src="/2022/10/10/22smartContract/2.png"></p><h2 id="智能合约是什么"><a href="#智能合约是什么" class="headerlink" title="智能合约是什么"></a>智能合约是什么</h2><blockquote><p>智能合约是一种特殊协议，旨在提供、验证及执行合约。</p></blockquote><p>智能合约的英文是 <code>Smart Contract</code>，这里的智能 Smart 不等同于人工智能的 Artificial Intelligence。Smart 的意思是聪明的、灵活的，还远远未达到 Intelligence 的级别。中文的翻译有点误导的意思。</p><p>智能合约本质上是一个数字协议，数字协议在我们日常生活很常见，比如信用卡自动还款服务就是一个数字协议，在某一个时间（还款日），条件满足（储蓄卡余额比信用卡还款金额要多）的情况下，计算机系统会自动完成这笔交易。自动售货机也是一个数字协议，当选择商品，付钱后，如果付的钱足以支付该商品，那么售货机会弹出想要的商品，如果钱不够则运行另一套逻辑。</p><p>所以，智能合约就是一段计算机程序，程序中预先设定好了合约双方的职责和要执行的条件，一旦满足条约中的条款，程序会自动执行。只是与传统数字协议不同的是，智能合约是运行在区块链上的。</p><p>站在程序员的角度去理解智能合约，可以类比为一个类实例化对象，唯一的区别是这个对象永远存在区块链网络中（除非程序进行自毁）。</p><h2 id="智能合约是怎么运行的"><a href="#智能合约是怎么运行的" class="headerlink" title="智能合约是怎么运行的"></a>智能合约是怎么运行的</h2><p>智能合约一定要在区块链上么？ 并不是，就像上面说的信用卡自动还款、自动售货机的例子。但是运行在传统的计算机方式中存在合约被恶意篡改之类风险，还有一个重要的信任问题。在信用卡自动还款的例子中，因为是银行的服务，有银行背书，许多人相信银行。如果把这个服务放在淘宝、京东这类网店上，还会有人相信么？ 即使从技术角度来说实现这种服务也并不难。</p><p>所以相对于传统的方式，区块链去中心化、不可篡改、过程透明可追踪、去信任等优点，天然适合于智能合约。智能合约也是区块链被称之为“去中心化的”重要原因，它允许我们在不需要第三方的情况下，执行可追溯、不可逆转和安全的交易。</p><p>基于区块链的智能合约构建及执行主要分为如下几步：</p><p><code>构建 → 存储 → 执行</code></p><ol><li>多方共同制定合约内容，将编写好的智能合约代码上传到区块链上，全网的验证节点都会收到编写好的合约。</li><li>智能合约会定期检查是否存在相关事件和触发条件，满足条件的事件将会推送到待验证的队列中。比如每月10号信用卡还款日，这个事件就是智能合约的触发条件。</li><li>区块链上的验证节点先对该事件进行签名验证，以确保其有效，等大多数验证节点对该事件达成共识后，智能合约将成功执行，并通知用户。</li><li>合约成功执行后将移出区块，未执行的合约则继续等待下一轮处理，直至成功执行。</li></ol><p>智能合约的代码是具体如何运行的，不同区块链运行的方式不同，像以太坊是运行在以太坊的 EVM 中，超级账本 Fabric 是运行在 dcoker 中。</p><p>基于区块链乌托邦式的智能合约虽然能够解决当前传统计算机合约下的许多问题，但是现阶区块链段智能合约仍然有一些缺点。</p><ul><li>区块链不可篡改的特性，智能合约一旦上链就不容易修改，这使得修改代码变得困难。</li><li>区块链公开透明的特性，使得所有的私人信息都进入了公共领域。对于想要完全隐私的企业和个人来说，缺乏保密性是使用智能合约的一大缺点。</li><li>区块链上的智能合约只是将信任问题进行了转移并没有得到解决，比如房产交易合约，房屋归属权上链的首要条件是现实生活中房产交付确认同样是必须的输入信息。也就是，区块链无法解决外部虚假信息的录入。</li></ul><p>互联网从诞生到成熟这条路走了有三十年，对于仅活跃几年的区块链智能合约，未来的路依旧会很漫长。</p><p><img src="https://img.soogif.com/zr4XXRlsRpSDwFA4N1wNkrWM923md01V.gif?scope=mdnice"></p>]]></content>
    
    
    <summary type="html">Szabo 描述了什么是“以数字形式指定的一系列承诺，包括各方履行这些承诺的协议”。虽然有它的好处，但智能合约的想法一直未取得进展——一个重要原因是因为缺乏能够支持可编程合约的数字系统和技术。</summary>
    
    
    
    <category term="web3" scheme="http://yaocl.cn/categories/web3/"/>
    
    
    <category term="web3" scheme="http://yaocl.cn/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>编译器对代码做了哪些工作</title>
    <link href="http://yaocl.cn/2022/09/15/21compile/"/>
    <id>http://yaocl.cn/2022/09/15/21compile/</id>
    <published>2022-09-15T06:21:36.000Z</published>
    <updated>2023-05-22T01:00:59.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>知乎上有一种说法是「编译器、图形学、操作系统是程序员的三大浪漫」。</p></blockquote><p>计算机很笨，它只认识 0 和 1,也只会运行最简单的机器指令，而我们平时写的代码大多都属于高级语言。高级语言编写的指令要想在计算机上执行，需要将高级语言转换成计算机识别的机器语言。编译器就是将高级语言转换成机器语言的一款软件。</p><p>一个完整的编译器将源码编译成目标机器指令主要包含以下几个步骤。</p><p><img src="/2022/09/15/21compile/1.png"></p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析从左到右扫描源程序的字符，识别出每个单词，并组成<code>词素</code>（源代码中的一个字符串，比如一个变量名，一个运算符，都会被识别为一个词素。）。对于每个词素，词法分析会把它解析成一个词法单元。这个词法单元被称为 Token。Token 的形式一般为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">〈token-name, attribute-value〉</span><br></pre></td></tr></table></figure><ul><li>token-name: 单词的类别</li></ul><p>程序中的单词大体可以分成五类：</p><p><img src="/2022/09/15/21compile/2.png"></p><ul><li>attribute-value： 指向符号表中关于这个词法单元的条目。符号表条目的信息会被语义分析和代码生成步骤使用</li></ul><p>什么是符号表？</p><p>编译器的重要功能之一是记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息。这些属性可以提供一个名字的存储分配、类型、作用域等信息。对于过程名字，这些信息还包括：它的参数数量和类型、每个参数的传递方法及返回类型。</p><p>符号表数据结构为每个变量名字创建了一个记录条目。记录的字段就是名字的各个属性。这个数据结构应该允许编译器迅速查找到每个名字的记录，并向记录中快速存放和获取记录中的数据。</p><p>比如，对于赋值语句<code>position = initial + 2 * 60</code></p><p><code>position</code>是一个词素，被映射成词法单元<code>&lt;id, 1&gt;</code>，其中 id 是表示标识符（identifier）的抽象符号，而 1 指向符号表中 position 对应的条目。</p><p>赋值符号<code>=</code>是一个词素，被映射成词法单元<code>&lt;=&gt;</code>，因为这个词法单元不需要属性值，所以省略了第二个分量。</p><p>整条语句被词法分析后的结果可以表示为<br><code>&lt;id, 1&gt; &lt;=&gt; &lt;id, 2&gt; &lt;+&gt; &lt;2&gt; &lt;*&gt; &lt;60&gt;</code></p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析对词法分析中扫描的 Token 进行分析，并产生语法树，这棵树被称为 AST 抽象语法树。整个分析过程采用的是上下文无关语法（Context-free Grammar）。</p><p>简单来说，语法分析生成的树是以表达式为节点的树。</p><p>比如，对于赋值语句<code>position = initial + 2 * 60</code>，经过语法分析后生成的数</p><p><img src="/2022/09/15/21compile/3.png"></p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语义分析利用前面生成的语法树和符号表来检查源程序是否符合语言定义。同时收集类型信息，以便在代码生成过程中使用。</p><p>语义分析的一个重要作用就是类型检查，编译器检查每一个运算符是否具有合法的运算分量。另外对于某些语言允许自动类型转换，编译器需要根据自动类型转换规则，对数据类型进行转换。</p><p>语义分析结束以后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换的，在分析完后会在语法书树上插入相应的转换节点。</p><p>比如<code>position = initial + 2 * 60</code> 经过语义分析后</p><p><img src="/2022/09/15/21compile/4.png"></p><p>语义分析同时还会对更新符号表里的符号类型。</p><h2 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h2><p>在经过语义分析后。大多数的编译器不会直接生成目标代码，一般会生成一个抽象于平台的中间语言(Intermediate Representation，简称 IR )，该中间语言与机器无关。</p><p>先生成中间代码一方面可以增加编译器的模块化、可移植性和可扩展性。中间代码既独立于任何高级语言，也独立于任何目标机器架构，这样可以开发出适应广泛高级语言的编译器。</p><p><img src="/2022/09/15/21compile/5.png"></p><p>另一方面，也可以做一些与机器无关的优化操作。</p><p>中间语言有很多种，在不同的编译器中可能也会有不同的表达形式。常用的方式有三地址码、P-代码等。</p><p>拿三地址码来举例，基本的三地址码是这样的<code>x = y op z</code>，表示将变量y和z操作后赋值给x，op既可以是算术运算也可以是其他的操作。 <code>position = initial + 2 * 60</code> 被三地址成三地址码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = 2 * 60</span><br><span class="line">t2 = initial + t1</span><br><span class="line">position  = t2</span><br></pre></td></tr></table></figure><h2 id="中间代码优化"><a href="#中间代码优化" class="headerlink" title="中间代码优化"></a>中间代码优化</h2><p>中间代码优化的主要是做一些于底层机器无关的优化，比如消除死代码，函数内联优化，for 循环展开等优化。这一步输入的是中间代码IR,输出的也是中间代码IR。</p><p><code>position = initial + 2 * 60</code> 被翻译成中间语言后，<code>t1 = 2 * 60</code> 是可以在生成目标代码之前计算出来的，<code>t2 = initial + t1</code> 中的t1也是可以直接被替换成值的。 经过优化后的中间代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t2 = initial + 120</span><br><span class="line">position  = t2</span><br></pre></td></tr></table></figure><h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p>目标代码生成的工作是将中间代码转换成目标机器代码，这个过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、数据类型等等，需要生成不同的机器代码。</p><p>现在编译器有着异常复杂的机构，因为现代高级语言本身非常的复杂，像C++编译器，至今也没有一个编译器能够完整的支持C++标准所规定的所有语言特性。 那么作为一个高级语言的使用者，为什么要学习编译原理呢？这里引用《三体》中的一段话结束。</p><blockquote><p>成吉思汗的骑兵，攻击速度与二十世纪的装甲部队相当;北宋的床弩，射程达一千五百米，与二十世纪的狙击步枪差不多;但这些仍不过是古代的骑兵与弓弩而已，不可能与现代力量抗衡。<code>基础理论决定一切</code>，未来史学派清楚地看到了这一点。而你们，却被回光返照的低级技术蒙住了眼睛。</p></blockquote>]]></content>
    
    
    <summary type="html">计算机很笨，它只认识 0 和 1,也只会运行最简单的机器指令，而我们平时写的代码大多都属于高级语言。高级语言编写的指令要想在计算机上执行，</summary>
    
    
    
    <category term="编译原理" scheme="http://yaocl.cn/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="http://yaocl.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java8中的Stream流</title>
    <link href="http://yaocl.cn/2022/08/20/20stream/"/>
    <id>http://yaocl.cn/2022/08/20/20stream/</id>
    <published>2022-08-20T06:15:48.000Z</published>
    <updated>2023-05-22T01:00:59.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是Stream流，Java doc中是这样写的</p><blockquote><p>A sequence of elements supporting sequential and parallel aggregate operations</p></blockquote><p>翻译一下就是一个支持顺序和并行聚合操作的元素序列。<br>可以把它理解成一个迭代器，但是只能遍历一次，就像是流水一样，要处理的元素在流中传输，并且可以在流中设置多个处理节点，元素在经过每个节点后会被节点的逻辑所处理。比如可以进行过滤、排序、转换等操作。</p><p>Stream流的使用可以分为三个步骤：</p><ul><li>数据源，创建流</li><li>中间操作，可以有多个，生成一个新的流</li><li>终端操作，只能有一个，放在最后，代表流中止。</li></ul><p>Stream流有几个特点：<br>1、Stream流一般不会改变数据源，只会生成一个新的数据流。<br>2、Stream流不会存储数据，只会根据设置的操作节点处理数据。<br>3、Stream流是延迟执行的，只有在调用终端操作后才会进行流转。</p><p>看一下Stream的结构<br><img src="/2022/08/20/20stream/1.png" alt="stream"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="数据源生成流"><a href="#数据源生成流" class="headerlink" title="数据源生成流"></a>数据源生成流</h3><ul><li>如果是集合的话，可以直接使用<code>stream()</code>创建流。</li><li>如果是数组的话，可以使用<code>Arrays.stream()</code>或<code>Stream.of()</code>来创建流。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合生成流</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = strList.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据生成流</span></span><br><span class="line">String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream1 = Arrays.stream(strs);</span><br><span class="line">Stream&lt;String&gt; stream2 = Stream.of(strs);</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3>在上边Stream定义中，返回是<code>Stream</code>类型的大多数都是中间操作，入参大多数都是函数式编程，不熟悉的可以看看这篇&lt;Java函数式编程&gt;。常用的中间操作有</li><li>过滤操作 <code>filter()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(strs).filter(s -&gt; s.equals(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>排序操作 <code>sorted()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(strs).sorted();</span><br></pre></td></tr></table></figure></li><li>去重操作 <code>distinct()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(strs).distinct();</span><br></pre></td></tr></table></figure></li><li>映射操作，将流中元素转换成新的元素<ul><li><code>mapToInt()</code>转换成Integer类型</li><li><code>mapToLong()</code>转换成Long类型</li><li><code>mapToDouble()</code>转换成Double类型</li><li><code>map()</code> 自定义转换类型，这是一个使用频率非常高的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符串转换成Integer</span></span><br><span class="line">Arrays.stream(strs).mapToInt(s -&gt; Integer.valueOf(s));</span><br><span class="line"><span class="comment">//将字符串转换成Long</span></span><br><span class="line">Arrays.stream(strs).mapToLong(s -&gt; Long.valueOf(s));</span><br><span class="line"><span class="comment">//将字符串转换成Doublde</span></span><br><span class="line">Arrays.stream(strs).mapToDouble(s -&gt; Double.valueOf(s));</span><br><span class="line"><span class="comment">//自定义转换的类型</span></span><br><span class="line">Arrays.stream(strs).map(s -&gt; <span class="keyword">new</span> BigDecimal(s));</span><br></pre></td></tr></table></figure>中间操作是可以有多个的，我们可以根据业务功能组合多个中间操作，比如求数组中字符串包含s的字符串长度排序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(strs).filter(e-&gt;e.contains(<span class="string">&quot;s&quot;</span>)).map(String::length).sorted();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><p>终端操作，表示结束流操作，是在流的最后，常用的有</p><ul><li>统计 <code>count()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = Arrays.stream(strs).count();</span><br><span class="line"><span class="comment">// count=3</span></span><br></pre></td></tr></table></figure></li><li>获取最小值 <code>min()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换成Interger类型再比较大小</span></span><br><span class="line"> OptionalInt min = Arrays.stream(strs).mapToInt(Integer::valueOf).min();</span><br><span class="line"> System.out.println(min.getAsInt());</span><br><span class="line"> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li>获取最大值 <code>max()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt max = Arrays.stream(strs).mapToInt(Integer::valueOf).max();</span><br><span class="line">System.out.println(max.getAsInt());</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li>匹配<ul><li><code>anyMatch()</code>，只要有一个匹配就返回<code>true</code></li><li><code>allMatch()</code>，只有全部匹配才返回<code>true</code></li><li><code>noneMatch()</code>，只要有一个匹配就返回 <code>false</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> all = Arrays.stream(strs).allMatch(s -&gt; s.equals(<span class="string">&quot;2&quot;</span>));</span><br><span class="line"><span class="keyword">boolean</span> any = Arrays.stream(strs).anyMatch(s -&gt; s.equals(<span class="string">&quot;2&quot;</span>));</span><br><span class="line"><span class="keyword">boolean</span> none = Arrays.stream(strs).noneMatch(s -&gt; s.equals(<span class="string">&quot;2&quot;</span>));</span><br><span class="line"><span class="comment">// all = false</span></span><br><span class="line"><span class="comment">// any = true</span></span><br><span class="line"><span class="comment">// none = false</span></span><br></pre></td></tr></table></figure></li></ul></li><li>组合 <code>reduce()</code>将Stream 中的元素组合起来，有两种用法<ul><li><code>Optional reduce(BinaryOperator accumulator)</code> 没有起始值只有运算规则</li><li><code>T reduce(T identity, BinaryOperator accumulator)</code>，有运算起始值和运算规则、返回的是和起始值一样的类型</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Optional&lt;Integer&gt; reduce1 = Arrays.stream(integers).reduce((i1, i2) -&gt; i1 + i2);</span><br><span class="line">Integer reduce2 = Arrays.stream(integers).reduce(<span class="number">100</span>, (i1, i2) -&gt; i1 + i2);</span><br><span class="line"><span class="comment">// reduce1.get() = 6</span></span><br><span class="line"><span class="comment">// reduce2 = 106</span></span><br></pre></td></tr></table></figure><ul><li>转换 <code>collect()</code>，转换作用是将流再转换成集合或数组，这也是一个使用频率非常高的方法。<br><code>collect()</code>一般配合<code>Collectors</code>使用，<code>Collectors</code> 是一个收集器的工具类，内置了一系列收集器实现，比如<code>toList()</code> 转换成list集合，<code>toMap()</code>转换成Map,<code>toSet()</code>转换成Set集合,<code>joining()</code> 将元素收集到一个可以用分隔符指定的字符串中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;11111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//统计每个字符串的长度</span></span><br><span class="line">List&lt;Integer&gt; lengths = Arrays.stream(strs).map(String::length).collect(Collectors.toList());</span><br><span class="line">String s = Arrays.stream(strs).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"><span class="comment">// lengths=[5,3,1]</span></span><br><span class="line"><span class="comment">// s = 11111,222,3</span></span><br></pre></td></tr></table></figure>合理的组合Steam操作，可以很大的提升生产力</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/2022/08/20/20stream/2.png"><br>Stream的实现类中，将Stream划分成了<code>Head</code>、<code>StatelessOp</code>和<code>StatefulOp</code>，<code>Head</code>控制数据流入，中间操作分为了<code>StatelessOp</code>和<code>StatefulOp</code>。</p><p>StatelessOp代表无状态操作：每个数据的处理是独立的，不会影响或依赖之前的数据。像<code>filter()</code>、<code>map()</code>等。</p><p>StatefulOp代表有状态操作：：处理时会记录状态，比如后面元素的处理会依赖前面记录的状态，或者拿到所有元素才能继续下去等这样有状态的操作，像<code>sorted()</code>。</p><p>现在已下面代码为例，分析一下Stream的原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(e -&gt; e.length() &gt; <span class="number">1</span>)</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter(e -&gt; e.equals(<span class="string">&quot;333&quot;</span>))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="数据源生成流-1"><a href="#数据源生成流-1" class="headerlink" title="数据源生成流"></a>数据源生成流</h3><p>首先，进入到<code>list.stream()</code>里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection#stream</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StreamSupport#stream</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原数据封装成<code>Spliterator</code>，同时生成一个<code>Head</code>，将<code>Spliterator</code>放到<code>Head</code>中。</p><p><img src="/2022/08/20/20stream/3.png"></p><h3 id="中间操作-1"><a href="#中间操作-1" class="headerlink" title="中间操作"></a>中间操作</h3><p>接着分析中间操作<code>.filter(e -&gt; e.length() &gt; 1)</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReferencePipeline#filter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                  StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的是一个无状态操作<code>StatelessOp</code>，查看<code>StatelessOp</code>的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPipeline#AbstractPipeline</span></span><br><span class="line">  AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">      <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">      previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">      previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">      <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">      <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">      <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">      <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">          sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>构造函数中有<code>previousStage.nextStage = this;</code>和<code>this.previousStage = previousStage;</code>，相当于将当前的<code>StatelessOp</code>操作拼接到<code>Head</code>后面，构成了一条双向链表。</p><p><img src="/2022/08/20/20stream/4.png"></p><p>再看后面的<code>.sorted().filter(e -&gt; e.equals(&quot;333&quot;)).limit(10)</code>，也会将操作添加到了双向链表后面。<code>.sorted()</code>在链表后面添加的是<code>StatefulOp</code>有状态操作。</p><p><img src="/2022/08/20/20stream/5.png"></p><h3 id="终端操作-1"><a href="#终端操作-1" class="headerlink" title="终端操作"></a>终端操作</h3><p>最后走到终端操作<code>.collect(Collectors.toList())</code>。进入到<code>collect()</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReferencePipeline#collect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> P_OUT, A, R&gt; collector)</span> </span>&#123;</span><br><span class="line">    A container;</span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">            ? (R) container</span><br><span class="line">            : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发操作先不看，直接看<code>container = evaluate(ReduceOps.makeRef(collector));</code>，<code>ReduceOps.makeRef()</code>返回是<code>TerminalOp</code>，代表的是终端操作。</p><p><img src="/2022/08/20/20stream/6.png"></p><p>进<code>evaluate()</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractPipeline#evaluate</span></span><br><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">            ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">            : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先不管并行，进串行入<code>evaluateSequential()</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReduceOps#evaluateSequential</span></span><br><span class="line"><span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makeSink()</code>将返回一个<code>Sink</code>实例，并作为参数和 spliterator 一起传入最后一个节点(terminalOp)的 wrapAndCopyInto() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractPipeline#wrapAndCopyInto</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wrapSink()</code>将最后一个节点创建的 Sink 传入，并且看到里面有个 for 循环。这个 for 循环是从最后一个节点开始，到第二个节点结束。每一次循环都是将上一节点的 combinedFlags 和当前的 Sink 包起来生成一个新的 Sink 。这和前面拼接各个操作很类似，只不过拼接的是 Sink 的实现类的实例，方向相反。</p><p><img src="/2022/08/20/20stream/7.png"></p><p>到现在整个流水已经拼接完成。真正的数据处理在<code>copyInto()</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractPipeline#copyInto</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sink</code>中有三个方法：</p><ul><li><code>begin</code>：节点开始准备</li><li><code>accept</code>: 节点处理数据</li><li><code>end</code>： 节点处理结束</li></ul><p><code>Sink</code>与操作是相关的，不同的<code>Sink</code>有不同的职责，无状态操作的 Sink 接收到通知或者数据，处理完了会马上通知自己的下游。有状态操作的 Sink 则像有一个缓冲区一样，它会等要处理的数据处理完了才开始通知下游，并将自己处理的结果传递给下游。</p><p>比如<code>filter</code>这种无状态的操作，处理完数据会直接交给下游，而像<code>sorted</code>这种无有状态的操作在<code>begin</code>阶段会先创建一个容器，<code>accept</code>会将流转过来的数据保存起来，最后在执行 <code>end</code>方法时才正在开始排序。排序之后再将数据，采用同样的方式依次传递给下游节点。<br><img src="/2022/08/20/20stream/8.png"></p><p>wrapAndCopyInto() 返回了 TerminalOps 创建的 Sink，这时候它里面已经包含了最终处理的结果。调用它的 get() 方法就获得了最终的结果。</p><p><code>Steam</code>还可以支持并行流，把<code>list.stream()</code>换成<code>list.parallelStream()</code>即可使用并行操作。</p><p>并行过程中，构建操作链的双向链表是不变的，区别实在构建完后的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractPipeline#evaluate</span></span><br><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">            ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">            : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这次进入到 <code>evaluateParallel()</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReduceOps#evaluateSequential</span></span><br><span class="line"><span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReduceTask&lt;&gt;(<span class="keyword">this</span>, helper, spliterator).invoke().get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReduceTask</code>继承自<code>ForkJoinTask</code>，<code>Steam</code>的并行底层用的是ForkJoin框架。</p>]]></content>
    
    
    <summary type="html">可以把它理解成一个迭代器，但是只能遍历一次，就像是流水一样，要处理的元素在流中传输，并且可以在流中设置多个处理节点，元素在经过每个节点后会被节点的逻辑所处理。比如可以进行过滤、排序、转换等操作。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>区块链的灵魂-共识机制</title>
    <link href="http://yaocl.cn/2022/07/15/19consensus/"/>
    <id>http://yaocl.cn/2022/07/15/19consensus/</id>
    <published>2022-07-15T06:11:40.000Z</published>
    <updated>2023-05-22T01:00:59.033Z</updated>
    
    <content type="html"><![CDATA[<p>区块链是去中心化、分布式的，每个人都可以自由的参与进来，共同处理区块链中的数据。所谓绝对的自由必然带来绝对的混乱，作为一个巨大的分布式计算网络，必然有一个绕不开的问题–拜占庭将军问题</p><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>拜占庭将军问题（Byzantine failures），是由计算机科学史上的传奇人物莱斯利·兰伯特（Leslie Lamport）提出的。</p><p>拜占庭帝国派出10个将军去攻击敌人，这支敌人可以同时抵御5支拜占庭军队的同时袭击。而这10个拜占庭将军在分开的状态下包围了敌人，并且只能依靠通信兵骑马相互通信来协商进攻意向及进攻时间。但是这些将军们不能确定他们的通信兵中是否有叛徒，叛徒可能擅自改变进攻意向及进攻时间。在这种情况下怎样才能保证同时有多于5支军队攻击，来赢得胜利？</p><p><img src="/2022/07/15/19consensus/1.png"></p><p>放到区块链中，拜占庭将军问题主要针对点对点通信中的分布式系统一致性问题。可以简单的概括为为 <code>在整个网络中的任意节点都无法信任与之通信的对方时，如何能创造出共识基础来进行安全信息的交互而无需担心数据被篡改。</code></p><p>区块链四大核心技术之一的共识机制就是为了解决这个问题。</p><h3 id="什么是共识机制？"><a href="#什么是共识机制？" class="headerlink" title="什么是共识机制？"></a>什么是共识机制？</h3><p>共识，对特定事务具有相同的认识或态度。 共识在我们的生活中无处不在，说一个场景<br>中午你和同事一起吃午饭，你们在讨论怎么吃，然后你出来提议一起点外卖。其他人对你的提议进行投票，如果没有异议那么这就达成了共识。</p><p><img src="/2022/07/15/19consensus/2.png"></p><p>区块链是一个点对点的分布式数据库结构的网络账本。这个账本与传统账本不同，不是由会计或少数几个人来记账，而是人人都可以参与记账。在没有中心机构的情况下，怎么确保别人的数据是正确的？</p><p>这就需要一套规则来规定<code>怎样记账才是有效的</code>，而这一套规则就是共识机制。</p><p>这一套规则主要有两点功能：</p><ul><li>如何记账</li><li>怎样达成共识</li></ul><p>按照这套规则来决定区块链中谁取得区块链中的记账权，也就决定着由谁来产生新的区块。</p><p>共识机制的作用非常大，直接关系到记账权和相关收益的分配。如果把区块链比作一个社会，那共识机制就是这个社会的法律。不夸张地说，共识机制就是区块链的灵魂。</p><p>区块链发展到现在，已经有了多种共识机制，这里主要介绍三种被提及最多的共识机制。</p><p><img src="/2022/07/15/19consensus/3.jpg"></p><h2 id="POW-工作量证明"><a href="#POW-工作量证明" class="headerlink" title="POW 工作量证明"></a>POW 工作量证明</h2><p>POW(Proof of Work)，工作量证明，闻名于比特币，经常提到的<code>挖矿</code>一词也是起源于POW。</p><p><img src="/2022/07/15/19consensus/4.png"></p><p>POW的设计思想是计算一道数学难题，这道题计算过程是复杂的，但是验证过程是简单的。这种特性称之为计算不对称特性。</p><p>比如在比特币中选定为以SHA256算法计算一个目标哈希，使得这个哈希值符合前N位全是0。 举个例子,给出一个字符串”Blockchain”，要求计算一个数字，与给出的字符串拼接起来，进行SHA256后，得到的结果前4位是0，这个数字称作nonce。比如字符串”Blockchain1234”，nonce就是1234。由于结果只能暴力搜索，而且搜索空间非常巨大，作弊几乎不可能。</p><p>只要计算出目标值nonce就会获得记账权，距离上一次打包到现在未确认的交易，就可以一次性将未确认的交易打包并广播了。其他节点在接收到消息后，可以对nonce进行验证。</p><p>简单来说POW就是谁的计算能力越强，计算的越快，获得记账权的概率就越高。每个节点都在同时解题，一旦有一个节点解出来，其余节点解题的过程也就白费了，只能解下一个节点。所以这种证明方式需要消耗大量能源(电力及计算硬件损耗)。</p><p>并且理论上，在POW共识机制保护下，如果一个节点的计算力超过区块链全网的51%，即可对区块链网络进行有效攻击。因此许多基于比特币代码产生的、市值较小的山寨币很容易遭受攻击。这个51%攻击法在「矽谷」这个美剧第四季上曾经上演过这个情节。</p><h2 id="POS-权益证明"><a href="#POS-权益证明" class="headerlink" title="POS 权益证明"></a>POS 权益证明</h2><p>POS(Proof of Stake), 权益证明，最早出现在点点币的创始人Sunny King的白皮书中，它出现的目地就是为了解决POW挖矿出现大量资源浪费的问题。</p><p>在POS中个有<code>币龄</code>的概念，它指的是持币数量乘以持币天数。<br>相较与POW中人人都可以参与，人人都可以计算，POW更像是一种选举机制。节点需要抵押一定的代币，区块链网络会根据抵押代币的币龄，随机选取一个节点，由该节点进行打包区块。 抵押代币的多少，影响着被选中的概率。</p><p><img src="/2022/07/15/19consensus/5.png"></p><p>这种方式不需要每个节点都进行大量的运算，节省了能源。但它同样也有一些缺点。比如，PoS机制中初始的代币分发比较模糊，如果初始代币分发不下去，就很难形成之后的权益证明。并且POS也存在51%的问题，理论上谁能掌握51%的代币，谁就能掌控整个网络，所以，它的去中心化程度要弱一些。</p><h2 id="DPOS-代理权益证明"><a href="#DPOS-代理权益证明" class="headerlink" title="DPOS 代理权益证明"></a>DPOS 代理权益证明</h2><p>DPOS(Delegated Proof of Stake),代理权益证明。最初由Bitshares、Steemit以及 EOS 的创办人Dan Larimer提出，他在区块链项目Bitshares中实现了 DPoS 共识机制。DPOS与POS类似也是一种选举机制，它有点像民主大会。</p><p>其过程是每一个持币人进行投票，选举出一定数量的代表，并由这些代表来打包区块和验证。这些代表节点的权利是相等的。比如，EOS将产生21个主节点，以及100个备用节点。如果有些代表节点不称职，就随时有可能被投票出局。</p><p><img src="/2022/07/15/19consensus/6.png"></p><p>DPOS就像董事会投票，持币者投出一定数量的节点 （董事）。代表按照既定时间表，轮流产生区块，如果代表没能很好的行使权力（比如产生区块），他们会被除名，网络会选出新的代表节点来取代他们。</p><p>DPOS通过选举少数节点来出块记账，确实从网络传输和确认时间上看，大幅提升了性能。但是只有少数的节点出块记账的理念，牺牲了部分去中心化。因为DPOS机制的设计并不能保证一定有足额的真实的区块生产者，因为一个人或一个实体，可能控制着多个节点。如果节点的持有人相互串通，将进一步形成巨头垄断，这和区块链思想更是南辕北辙。这也是为什么V神怒怼DPOS的原因。</p>]]></content>
    
    
    <summary type="html">区块链是去中心化、分布式的，每个人都可以自由的参与进来，共同处理区块链中的数据。所谓绝对的自由必然带来绝对的混乱，作为一个巨大的分布式计算网络，</summary>
    
    
    
    <category term="web3" scheme="http://yaocl.cn/categories/web3/"/>
    
    
    <category term="web3" scheme="http://yaocl.cn/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>认识区块链和web3.0</title>
    <link href="http://yaocl.cn/2022/06/19/18web3/"/>
    <id>http://yaocl.cn/2022/06/19/18web3/</id>
    <published>2022-06-19T03:55:17.000Z</published>
    <updated>2023-05-22T01:00:59.030Z</updated>
    
    <content type="html"><![CDATA[<p>2017-2018年期间，伴随着比特币的又一轮牛市，第一次认识和了解了区块链。<br>2019年，高层大佬们集体学习区块链，也跟着重新关注起了区块链。也是因为区块链，去年第一次接触到了Web3.0，给我的第一印象是这东西太过超前了，如果真的能落地，那真的又是一场技术革命了，从那以后陆陆续续的关注着。<br>今年下半年换了份工作，发现公司做区块链的大牛也在关注Web3.0，也跟着学习长进了不少。<br>这篇文章主要介绍一些区块链和Web3.0的基本知识，可以对区块链和Web3.0有个大概的了解。</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p><img src="/2022/06/19/18web3/web31.png"></p><p>2008年，全球金融危机，全世界掀起了反思传统金融制度的思潮，一个叫中本聪的人在P2P foundation网站上发布了比特币白皮书<a href="https://bitcoin.org/bitcoin.pdf">《比特币：一种点对点的电子现金系统》</a>。</p><p><img src="/2022/06/19/18web3/web32.png"></p><p>在书里提出了一种无须可信第三方的电子支付系统——比特币，通过整合非对称加密技术、工作量证明机制（Proof of Work，简称PoW）、点对点技术（Peer-to-Peer，简称P2P）等来保障个人对资产的所有权和匿名性，彻底颠覆了对于货币需要依赖中心化机构发行的传统认知。</p><p>区块链和比特币由此诞生，那区块链到底是什么呢？。<br>可以把区块链理解成一个数据库，这个数据库有几个重要的特点：</p><ul><li>  去中心化</li><li>  不可篡改</li><li>  透明性</li></ul><p>区块链是怎么做到这些的呢？先看一下区块链的大致结构。</p><p><img src="/2022/06/19/18web3/web33.png"></p><p>区块链可以大致理解为： 由一笔一笔的交易组成一个区块，一个一个的区块组成的一条链。这里的交易不单单指的双方买卖，双方发生的任何业务都可以称为交易。</p><p>整个区块链是由所有参与节点共同维护的，每个节点都可以保存区块链的全部数据。</p><p>在区块链系统里，每当发生一个交易，交易都是双方是直接进行的。交易的双方会把交易信息广播到整个交易系统里，系统中的一些节点会将这些交易打包成区块，并广播到整个区块链系统中，这些节点就可以称为矿工，而打包的过程就是挖矿。系统中的节点会对矿工打包的区块进行验证，验证通过则放到区块链中。</p><p>在每个区块的头部包含了上一个区块的哈希值，这个哈希值是由上个区块中的内容生成的，如果某个节点想要修改某个区块中的内容，那么该区块的哈希值也会改变，该区块以后所有的区块也都需要改变。这就相当与以一己之力对抗系统中的所有人，当系统中的节点多的时候，这种操作可以说是几乎不可能的。</p><p>区块链从诞生到现在，整个发展过程可以简单的划分为3个阶段：</p><h3 id="1、-区块链1-0-以比特币为代表的数字货币阶段"><a href="#1、-区块链1-0-以比特币为代表的数字货币阶段" class="headerlink" title="1、 区块链1.0 以比特币为代表的数字货币阶段"></a>1、 区块链1.0 以比特币为代表的数字货币阶段</h3><p><img src="/2022/06/19/18web3/web34.png"></p><p>比特币的出现，催生出了区块链，但是比特币区块链，所有规则是事先写好的，没有人可以在比特币区块链上修改任何规则，你只能用它，而不能在它的基础上再去发展。也就是说这一时期的区块链，只是为了服务与特定的业务，并不能作为一个通用的平台。以太坊对于区块链技术而言，是一次飞跃性的突破，它让区块链商业应用变得可能。</p><h3 id="2、-区块链2-0-以太坊为代表的智能合约阶段"><a href="#2、-区块链2-0-以太坊为代表的智能合约阶段" class="headerlink" title="2、 区块链2.0 以太坊为代表的智能合约阶段"></a>2、 区块链2.0 以太坊为代表的智能合约阶段</h3><p><img src="/2022/06/19/18web3/web35.png"></p><p>2015年，一个新的公链出现，叫做以太坊。并将智能合约带到了区块链中。以太坊可以被看作是一台<code>全球计算机</code>，它允许所有人在以太坊区块链的基础上做其他的应用开发。</p><h3 id="3、-区块链3-0-开始超出金融行业，为各行各业提供解决方案，为新的互联网理念web3-0提供支持。"><a href="#3、-区块链3-0-开始超出金融行业，为各行各业提供解决方案，为新的互联网理念web3-0提供支持。" class="headerlink" title="3、 区块链3.0 开始超出金融行业，为各行各业提供解决方案，为新的互联网理念web3.0提供支持。"></a>3、 区块链3.0 开始超出金融行业，为各行各业提供解决方案，为新的互联网理念web3.0提供支持。</h3><p><img src="/2022/06/19/18web3/web36.png"></p><h2 id="Web3-0"><a href="#Web3-0" class="headerlink" title="Web3.0"></a>Web3.0</h2><p><img src="/2022/06/19/18web3/web37.png"></p><p>说起Web3.0,先要从Web1.0和Web2.0说起。</p><h3 id="1、Web1-0-静态互联网"><a href="#1、Web1-0-静态互联网" class="headerlink" title="1、Web1.0 静态互联网"></a>1、Web1.0 静态互联网</h3><p>Web1.0时期，也称为静态互联网时期，是互联网发展的第一个阶段，这一阶段互联网上的内容是由平台提供，用户只能<code>读取信息</code>而不能写入信息。最典型的互联网产品是门户网站、搜索引擎等工具。代表性的有搜狐、新浪和网易三大门户网站。</p><h3 id="2、Web2-0-平台互联网"><a href="#2、Web2-0-平台互联网" class="headerlink" title="2、Web2.0 平台互联网"></a>2、Web2.0 平台互联网</h3><p>Web2.0时期，也就是我们现在所处的时期，被称为平台互联网时期。Web2.0的概念在2004年始于出版社经营者O’Reilly和Media Live International之间的一场头脑风暴论坛。当时对Web2.0的讨论也像今天我们讨论Web3.0一样激烈。</p><p>Web2.0相比于Web1.0更加注重用户的交互，用户既可以是网站内容的浏览者也可以是内容的创造者，由以前的只能<code>读</code>向<code>写</code>和<code>共同建设</code>发展。用户也参与到互联网的发展。开始慢慢全面移动化，同时平台经济崛起，比如百度、阿里、腾讯、字节。</p><p>但是随着Web2.0的发展，平台互联网的弊端也越来越让人难以接受，所谓天下苦平台互联网时代久矣。当下的平台互联网：用户创造、平台所有、平台控制、平台分配、平台垄断、隐私泄漏等问题，形成了平台吞噬一切的现象。</p><p>2019年，《纽约时报》发布了一篇名为《减少互联网是唯一的答案》（The Only Answer Is Less Internet）的文章，对Web2.0时代的平台垄断、数据隐私、假新闻等问题进行了严厉批评。随着各国监管机构逐渐加强对互联网行业的监管，赢家通吃不再是互联网的铁律，合规化运营与寻找新增量成了行业发展的迫切需求，这也为Web3.0的到来埋下了伏笔。</p><h3 id="3、Web3-0-价值互联网"><a href="#3、Web3-0-价值互联网" class="headerlink" title="3、Web3.0 价值互联网"></a>3、Web3.0 价值互联网</h3><p>那里有压迫，那里就有反抗。在经历了一系列Web2.0弊端后，区块链时代的Web3.0出现了。</p><p>其实Web3.0一直是一个动态变化的过程，在区块链技术没有诞生之前，Web3.0通常意味这是一个更加智能的互联网，能够理解语义进行判断。在区块链诞生之后，Web3.0一般指建立在区块链技术之上的去中心化、去信任、无须许可的下一代互联网。</p><p>Web3.0有一下主要几个特点：</p><ul><li><p>  去中心化、去信任，不依赖第三方机构运作，避免平台吞噬一切</p></li><li><p>  可拥有，用户可以掌握自己在互联网上的数据和数字资产</p></li><li><p>  无须许可，代码开源、抗审查、可自由接入</p></li><li><p>全球化，资产在全球自由流动<br>  ……</p></li></ul><p>Web3.0的核心理念为数据的所有权归用户所有，每个人都可以控制自己的身份、数据和资产。</p><p>比如，我写了一篇文章，我授权给了某个平台，平台展示我的文章，并在文章下产生了一些评论。如果有一天我觉着这个平台不靠谱，我可以取消授权，同时将文章和评论授权给别的平台。实现真正的我的数据归我所有。</p><p>从2008年中本聪发布比特币白皮书，到2021年NFT和元宇宙的爆发，Web3.0已经从一小撮极客圈子，逐渐发展成为了一个庞大的科技产业，并且在多个方面带来了技术和应用</p><ul><li><p>去中心化金融(Defi)</p><p>  无须中心化的金融机构，即可实现传统金融中的贷款、保险、理财、股票等服务。比如Maker、Compound用于借贷的平台</p></li><li><p>非同质化代币(NFT)</p><p>  NFT有可验证、唯一、不可分割和可追溯的特性，可以用来标记特定资产，在数字货币中是重要的工具。比如著名球星库里花18万美元买一个NFT数字头像、游戏方面的GameFi、国内阿里，腾讯等推出的数字藏品等。</p></li><li><p>分布式自治组织(Dao)</p><p>  没有公司章程、没有层级制度、没有董事会，完全依靠民主治理、由参与者共同投票决定。比如Aragon、Moloch等Dao操作系统</p></li><li><p>  元宇宙</p></li></ul><p>可能大家还是觉着Web3.0现在还只是概念居多，但是在资本市场上Web3.0早已成为投资人眼里的香饽饽。</p><ul><li>  全球最大的风险投资公司之一的红杉资本一口气投资了20多家Web3.0公司。</li></ul><p>在政府层面上，也是同样在你追我敢</p><ul><li><p>  美国出台支持性政策，要保证Web3.0革命发生在美国。</p></li><li><p>  今年中国证监会科技监管局局长在《中国金融》杂志上撰文指出，“如今互联网正处在Web2.0向Web3.0演进的重要时点，加强Web3.0前瞻研究和战略预判，对我国未来互联网基础设施建设无疑具有重要意义。”</p></li><li><p>  10月31号，香港财政司正式发布《有关香港虚拟资产发展的政策宣言》，迎接Web3.0。</p></li></ul><p>处在风口的Web3.0到底是资本炒作的工具，还是一场真正的技术革命？</p><p>屠龙少年会不会终成恶龙？</p><p>让我们拭目以待。</p>]]></content>
    
    
    <summary type="html">Web3.0的核心理念为数据的所有权归用户所有，每个人都可以控制自己的身份、数据和资产。</summary>
    
    
    
    <category term="web3" scheme="http://yaocl.cn/categories/web3/"/>
    
    
    <category term="web3" scheme="http://yaocl.cn/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器</title>
    <link href="http://yaocl.cn/2022/05/27/classload/"/>
    <id>http://yaocl.cn/2022/05/27/classload/</id>
    <published>2022-05-27T14:45:47.000Z</published>
    <updated>2023-05-22T01:00:59.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>我们写的每一个Java文件，首先通过编译器编译成class文件，然后经过类加载器加载到jdk运行时内存中生成一个class类，才会被程序使用。而类加载器就是加载字节码(.class)文件的类–<code>java.lang.ClassLoader</code>。</p><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>Java默认设置了三个类加载器。</p><ul><li>BootstrapClassloader</li><li>ExtClassloader</li><li>AppClassloader  </li></ul><p>BootstrapClassloader 叫做启用类加载器，用于加载JRE核心类库，使用C++实现。加载路径%JAVA_HOME%/lib下的所有类库。  </p><p>ExtClassloader 扩展类加载器，加载%JAVA_HOME%/lib/ext中的所有类库。  </p><p>AppClassloader 应用类加载器也叫系统类加载器System Classloader，加载%CLASSPATH%路径下的所有类库。</p><p>Java 也提供了扩展，可以让我们自己实现类加载的功能。类加载器在Java中是<code>java.lang.ClassLoader</code>这个类，如果要自定义类加载器，只要实现这个类，重写加载方法就好了。</p><p>在Java中，由不同的类加载器加载的两个相同的类在Java虚拟机里是两个不同的类，那么Java是怎么确保一个类不会被多个类加载器重复加载，并且保证核心API不会被篡改的呢？  </p><p>这就需要Java的双亲委派机制。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="/2022/05/27/classload/classload.png"></p><p>1、当一个类加载器接到加载类的请求后，首先会交给父类去加载，如果所有父类都无法加载，自己加载，并将被加载的类缓存起来。。</p><p>2、每加载一个类，所有的类加载器都会判断是否可以加载，最终会委托到启动类加载器来首先加载。所有的类的加载都尽可能由顶层的类加载器加载，这样就保证了加载的类的唯一性。  </p><p>3、启动类加载器、扩展类加载器、应用程序类加载器，都有自己加载的类的范围，因此并不是所有的类父类都可以加载。</p><p>Java 类加载器中还有一个全盘委托机制，当指定一个<code>ClassLoader</code>加载一个类时，该类所依赖或者引用的类也会由这个类加载器来加载，除非显示的用别的类加载器加载</p><p>比如：程序入口默认用的是<code>AppClassloader</code>，那么以后创建出来的类也是用<code>AppClassloader</code>来加载，除非自己显示的用别的类加载器去加载。(classX引用了classY，那么ClassX的类加载器就会去加载classY(前提是classY尚未被加载))</p><h3 id="线程上下文加载器"><a href="#线程上下文加载器" class="headerlink" title="线程上下文加载器"></a>线程上下文加载器</h3><p>因为双亲委派机制的存在，每个类加载器都有自己的加载范围。但是在JDK中提供了很多服务提供者接口（Service Provider Interface，SPI），他们允许第三方来实现接口，比如常见的JDBC、JNDI、JAXP等。  </p><p> 这些接口是由Java核心库提供的，并由启用类加载器(BootstrapClassloader)加载，而实现确是在Java应用所依赖的第三方Jar包里的，默认是由应用类加载器(AppClassloader)加载。 </p><p>Java引入了线程上下文加载器的概念来打破双亲委派机制。 通过线程<code>Thread</code>类的<code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>来设置线程上下文加载器。如果没有通过<code>setContextClassLoader(ClassLoader cl)</code>进行设置的话，线程将继承其父线程的上下文类加载器。</p><p>线程上下文加载器并不是一个真实存在的类，而是一个概念。它是Thread类里的一个成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       contextClassLoader = cl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (contextClassLoader == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                                  Reflection.getCallerClass());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">我们写的每一个Java文件，首先通过编译器编译成class文件</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java工具 Jstack 的使用</title>
    <link href="http://yaocl.cn/2022/04/27/jstack/"/>
    <id>http://yaocl.cn/2022/04/27/jstack/</id>
    <published>2022-04-27T09:28:24.000Z</published>
    <updated>2023-05-22T01:00:59.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jstack - Prints Java thread stack traces for a Java process, core file, or remote debug server.</p></blockquote><p>Jstack主要的作用是生成当前进程中所有线程的信息，也就是当前时刻JVM的线程快照，通过线程的信息我们可以定位到程序中出现长时间停顿、CPU占用率过高等问题。</p><p>线程快照中的信息是当前java虚拟机内每一条线程正在执行的方法的堆栈集合，有了堆栈信息我们就可以分析出我们的程序问题出现在哪，比如线程间死锁、外部资源请求时间过长、死循环等。</p><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jstack [ options ] pid</span><br><span class="line"></span><br><span class="line">jstack [ options ] executable core</span><br><span class="line"></span><br><span class="line">jstack [ options ] [ server-id@ ] remote-hostname-or-IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">       -F</span><br><span class="line">              Force a stack dump when jstack [-l] pid does not respond.</span><br><span class="line"></span><br><span class="line">       -l</span><br><span class="line">              Long listing. Prints additional information about locks such as a list of owned java.util.concurrent ownable synchronizers. See the</span><br><span class="line">              AbstractOwnableSynchronizer class description at</span><br><span class="line">              http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractOwnableSynchronizer.html</span><br><span class="line"></span><br><span class="line">       -m</span><br><span class="line">              Prints a mixed mode stack trace that has both Java and native C/C++ frames.</span><br></pre></td></tr></table></figure><ul><li>-F  当正常的请求不被响应时，强制输出堆栈信息。</li><li>-l  额外打印锁的信息，当发生死锁时可以查看锁的信息</li><li>-m 如果调用本地方法栈的信息，可以打印C/C++的堆栈</li></ul><p>以一个发生死锁的例子来看一下使用Jstack查看到的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jstack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第一个线程拿到obj1的锁，等待obj2的锁，第二个线程拿到obj2的锁，等待obj1的锁，这样就会发生死锁。</p><p>先通过<code>jps</code>命令获取到先拿到当前的进程pid，然后通过jstack获取线程的信息。可以看到有两个线程都处于阻塞状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; #12 prio=5 os_prio=0 tid=0x00007fdff871c800 nid=0x3cc2 waiting for monitor entry [0x00007fdfce0fc000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.example.demo.jstack.Jstack.lambda$main$1(Jstack.java:36)</span><br><span class="line">- waiting to lock &lt;0x000000076e925a90&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x000000076e925aa0&gt; (a java.lang.Object)</span><br><span class="line">at com.example.demo.jstack.Jstack$$Lambda$2/2052001577.run(Unknown Source)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot; #11 prio=5 os_prio=0 tid=0x00007fdff871a800 nid=0x3cc1 waiting for monitor entry [0x00007fdfce1fc000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.example.demo.jstack.Jstack.lambda$main$0(Jstack.java:25)</span><br><span class="line">- waiting to lock &lt;0x000000076e925aa0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x000000076e925a90&gt; (a java.lang.Object)</span><br><span class="line">at com.example.demo.jstack.Jstack$$Lambda$1/1174361318.run(Unknown Source)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>第一行显示线程名、线程优先级、线程id、线程状态描述等信息</p><p>第二行显示的是当前线程的状态</p><p>​      Java中线程的状态分为NEW、RUNNABLE、BLOCKED、WATING、TIMED_WATING、TERMINATED，但是在快照中NEW状态是不会出现的。</p><p>再下面的就是当前线程的调用栈的信息。调用栈中包含了锁的信息。</p><p>​     <code>locked    </code>   表示使用synchronized申请对象锁成功,监视器的拥有者</p><p>​     <code>waiting to lock </code>  表示使用synchronized申请对象锁未成功,进入等待区。</p><p>​     <code>waiting on</code>    表示用synchronized申请对象锁成功后,调用了wait方法,进入对象的等待区等待。</p><p>​    <code>parking to wait for</code>  park是基本的线程阻塞原语,不通过监视器在对象上阻塞。随concurrent包会出现的新的机制,与synchronized体系不同。</p><p>在最后也显示出了代码中出现死锁的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fdfac006638 (object 0x000000076e925a90, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007fdfac003da8 (object 0x000000076e925aa0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">at com.example.demo.jstack.Jstack.lambda$main$1(Jstack.java:36)</span><br><span class="line">- waiting to lock &lt;0x000000076e925a90&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x000000076e925aa0&gt; (a java.lang.Object)</span><br><span class="line">at com.example.demo.jstack.Jstack$$Lambda$2/2052001577.run(Unknown Source)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">at com.example.demo.jstack.Jstack.lambda$main$0(Jstack.java:25)</span><br><span class="line">- waiting to lock &lt;0x000000076e925aa0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x000000076e925a90&gt; (a java.lang.Object)</span><br><span class="line">at com.example.demo.jstack.Jstack$$Lambda$1/1174361318.run(Unknown Source)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>好了，熟悉了Jstack，我们用一段死循环的代码，通过Jstack来定位到使CPU占用100%的代码行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JstackDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Executor executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Task task1 = <span class="keyword">new</span> Task();</span><br><span class="line">        Task task2 = <span class="keyword">new</span> Task();</span><br><span class="line">        executor.execute(task1);</span><br><span class="line">        executor.execute(task2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                run0();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、首先通过<code>top</code>查看到使CPU占用到100%的进程id</p><p>  <img src="/2022/04/27/jstack/top.png"></p><p>2、使用<code>top -Hp 进程id</code> 查看占用CPU最多的线程id</p><p><img src="/2022/04/27/jstack/top-Hp.png"></p><p>3、将线程id转换为16进制</p><p> 17997 -&gt; 464d</p><p>4、使用Jstack查看Java所在的进程，并找到相应的线程</p><p><img src="/2022/04/27/jstack/run0.png"></p>]]></content>
    
    
    <summary type="html">Jstack主要的作用是生成当前进程中所有线程的信息，也就是当前时刻JVM的线程快照，通过线程的信息我们可以定位到程序中出现长时间停顿、CPU占用率过高等问题。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 内存泄露问题</title>
    <link href="http://yaocl.cn/2022/04/06/threadlocal/"/>
    <id>http://yaocl.cn/2022/04/06/threadlocal/</id>
    <published>2022-04-06T09:13:44.000Z</published>
    <updated>2023-05-22T01:00:59.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。  ——百度百科</p></blockquote><p>上述的意思用在java中就是存在已经没有任何引用的对象，但是GC又不能把对象所在的内存回收掉，所以就造成了内存泄漏。</p><p>ThreadLocal主要解决的是对象不能被多个线程同时访问的问题。根据ThreadLocal的源码看看它是怎么实现的。</p><p>ThreadLocal设置数据的<code>set()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到在使用ThreadLocal设置数据时，其实设置到的是当前线程的threadLocals字段里，去Thread里看一看threadLocals变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>threadLocals的类型是ThreadLocal里的内部类ThreadLocalMap，ThreadLocalMap的中用来存储数据的又是一个内部类是<code>Entry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">       Object value;</span><br><span class="line"></span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>Entry</code>的key是当前ThreadLocal，value值是我们要设置的数据。</p><p><code>WeakReference</code>表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。</p><p>因为<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，所以在<code>Entry</code>中<code>ThreadLocal</code>是弱引用，一旦发生GC，<code>ThreadLocal</code>会被GC回收掉，但是<code>value</code>是强引用，它不会被回收掉。用一张图来表示一下</p><p><img src="/2022/04/06/threadlocal/ThreadLocal.png" alt="ThreadLocal"></p><p>图中实线表示的是强引用，虚线表示的是弱引用。</p><p>当JVM发生GC后，虚线会断开应用，也就是key会变为null，value是强引用不会为null，整个Entry也不为null，它依然在ThreadLocalMap中，并占据着内存，</p><p>我们获取数据时，使用ThreadLocal的<code>get()</code>方法，ThreadLocal并不为null，所以我们无法通过一个key为null去访问到该entry的value。这就造成了内存泄漏。</p><p>既然用弱引用会造成内存泄漏，直接用强引用可以么？</p><p>答案是不行。如果是强引用的话，看看下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">threadLocal.set(<span class="keyword">new</span> Object());</span><br><span class="line">threadLocal = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>我们在设置完数据后，直接将threadLocal设为null，这时栈中<code>ThreadLocal Ref</code> 到堆中<code>ThreadLocal</code>断开了，但是<code>key</code>到<code>ThreadLocal</code>的引用依然存在，GC依旧没法回收，同样会造成内存泄漏。</p><p>那弱引用比强引用好在哪？</p><p>当key为弱引用时，同样是上面代码，当threadLocal设为null时，栈中<code>ThreadLocal Ref</code> 到堆中<code>ThreadLoacl</code>断开了，<code>key</code>到<code>ThreadLoacl</code>也因为GC断开了，这时<code>ThreadLocal</code>就可以被回收了。</p><p>同时,ThreadLocal也可以根据<code>key.get() == null</code> 来判断key是否已经被回收，因此ThreadLocal可以自己清理这些过期的节点来避免内存泄漏。</p><p>其实，ThreadLocal做了很大的工作清除过期的key来避免发生内存泄漏</p><ol><li><p>在调用<code>set（）</code>方法时，会进行清理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">   </span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">// 当key为null时，替换掉</span></span><br><span class="line">          <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">              replaceStaleEntry(key, value, i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 清理一些槽位，清理过期key</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>1、 当key为null时，说明该位置被GC回收了，会将当前位置覆盖掉。</p><p>2、 在<code>set()</code>方法最后调用了<code>cleanSomeSlots()</code>中还会有清理的操作。看一看<code>cleanSomeSlots()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 真正的清理工作</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><code>cleanSomeSlots()</code>中当判断<code>e != null &amp;&amp; e.get() == null</code>为true时，说明已经被GC回收了，会调用<code>expungeStaleEntry()</code>进行清理工作，具体的逻辑就不再看了。</p></li><li><p>在调用<code>get()</code>方法时，如果没有命中，会向后查找，也会进行清理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">     Entry e = table[i];</span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">         <span class="keyword">return</span> e;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">// 没有命中向后查找</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">         <span class="keyword">if</span> (k == key)</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">             <span class="comment">// 当key为null，说明被GC回收了，进行清理的操作</span></span><br><span class="line">             expungeStaleEntry(i);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             i = nextIndex(i, len);</span><br><span class="line">         e = tab[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>调用<code>remove()</code>时，除了清理当前节点，还会向后进行清理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">             e.clear();</span><br><span class="line">             <span class="comment">// 向后查找，进行清理操作</span></span><br><span class="line">             expungeStaleEntry(i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 打包成Jar包运行的原理</title>
    <link href="http://yaocl.cn/2022/04/05/springbootjar/"/>
    <id>http://yaocl.cn/2022/04/05/springbootjar/</id>
    <published>2022-04-05T02:18:55.000Z</published>
    <updated>2023-05-22T01:00:59.076Z</updated>
    
    <content type="html"><![CDATA[<p>相比于传统的Java打包方式，使用SpringBoot打包插件打包成jar包后，可以直接使用<code>java -jar</code> 运行SpringBoot项目，本篇就来分析一下运行的原理。</p><p>SpringBoot打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打包完后会生成两个文件，一个<code>***.jar</code>和<code>***.jar.original</code></p><p><code>.jar</code>文件是SpringBoot打包后生成的文件，<code>.jar.original</code>是用原生方式打包生成的文件，对比一下两个的区别</p><p><code>.jar.original</code>文件</p><p><img src="/2022/04/05/springbootjar/jar.png" alt="original"></p><p><code>.jar</code>文件</p><p><img src="/2022/04/05/springbootjar/springbootjar.png" alt="jar"></p><p><code>.jar.original</code>就是普通的jar打包的结构，这里主要看<code>.jar</code>文件的结构：</p><ul><li><p>META-INFO目录：META-INFO/MANIFEST.MF里包含了jar包的元数据，包含了项目的启动类等信息.</p></li><li><p>org目录：该目录下包含的是启动项目的一些类，启动的过程就在这个包里。</p></li><li><p>BOOT-INFO目录：本地项目的代码（BOOT-INF/classes），以及所需的依赖（BOOT-INFO/lib）</p></li></ul><p>重点在META-INFO/MANIFEST.MF里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx</span><br><span class="line">Implementation-Title: demo</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Spring-Boot-Layers-Index: BOOT-INF/layers.idx</span><br><span class="line">Start-Class: com.example.demo.DemoApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Spring-Boot-Version: 2.4.5</span><br><span class="line">Created-By: Maven Jar Plugin 3.2.0</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>这里有几个重点的字段</p><ul><li>Main-Class ：jar包启动类，这是java规定的字段，存在这个字段的情况下， 在<code>java -jar</code>时，jar包才会运行起来</li><li>Start-Class：本地项目的启动类</li><li>Spring-Boot-Classes：加载应用类的入口</li><li>Spring-Boot-Lib：项目所需的依赖</li></ul><p>有了Main-Class启动类，那就直接进入到<code>JarLauncher</code>里查看运行的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> JarLauncher()).launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>JarLauncher</code>的<code>main</code>方法里调用了<code>launch</code>方法，<code>launch</code>方法的具体实现在<code>JarLauncher</code>的抽象父类<code>Launcher</code>中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isExploded()) &#123;</span><br><span class="line">        JarFile.registerUrlProtocolHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassLoader classLoader = <span class="keyword">this</span>.createClassLoader(<span class="keyword">this</span>.getClassPathArchivesIterator());</span><br><span class="line">    String jarMode = System.getProperty(<span class="string">&quot;jarmode&quot;</span>);</span><br><span class="line">    String launchClass = jarMode != <span class="keyword">null</span> &amp;&amp; !jarMode.isEmpty() ? <span class="string">&quot;org.springframework.boot.loader.jarmode.JarModeLauncher&quot;</span> : <span class="keyword">this</span>.getMainClass();</span><br><span class="line">    <span class="keyword">this</span>.launch(args, launchClass, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>首先获取了类加载器。</p></li><li><p>然后获取jarMode，再根据jarMode获取launchClass，如果没有设置jarMode，则根据<code>getMainClass</code>方法获取，<code>getMainClass</code>的具体实现在<code>ExecutableArchiveLauncher</code>中实现</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getMainClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Manifest manifest = <span class="keyword">this</span>.archive.getManifest();</span><br><span class="line">       String mainClass = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (manifest != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mainClass = manifest.getMainAttributes().getValue(<span class="string">&quot;Start-Class&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (mainClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No &#x27;Start-Class&#x27; manifest entry specified in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> mainClass;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>​     在<code>getMainClass</code>里获取了<code>MANIFEST.MF</code>文件里<code>Start-Class</code>字段的值，也就是本地项目的启动类。</p><ul><li><p>最后调用<code>this.launch(args, launchClass, classLoader);</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String launchClass, ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">    <span class="keyword">this</span>.createMainMethodRunner(launchClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 调用<code>MainMethodRunner</code>的<code>run()</code>方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; mainClass = Class.forName(<span class="keyword">this</span>.mainClassName, <span class="keyword">false</span>, Thread.currentThread().getContextClassLoader());</span><br><span class="line">    Method mainMethod = mainClass.getDeclaredMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">    mainMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    mainMethod.invoke((Object)<span class="keyword">null</span>, <span class="keyword">this</span>.args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>run()</code>方法里通过反射拿到了项目的启动类的<code>main</code>方法，从而启动本地项目。</p>]]></content>
    
    
    <summary type="html">相比于传统的Java打包方式，使用SpringBoot打包插件打包成jar包后，可以直接使用`java -jar` 运行SpringBoot项目，本篇就来分析一下运行的原理。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="Spring Boot" scheme="http://yaocl.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>设计一个支持热加载的Java应用启动器</title>
    <link href="http://yaocl.cn/2021/12/29/hot-loading/"/>
    <id>http://yaocl.cn/2021/12/29/hot-loading/</id>
    <published>2021-12-29T03:53:19.000Z</published>
    <updated>2023-05-22T01:00:59.070Z</updated>
    
    <content type="html"><![CDATA[<p>热加载是指在不重启服务的情况下使更改的代码生效。注意和热部署的区别，热加载主要是在开发环境下使用。</p><p>首先要知道Java程序是怎么运行起来的，Java类加载分为其7个阶段。</p><p><img src="/2021/12/29/hot-loading/phase.png" alt="phase"></p><p>其中加载阶段是用户可以自定义，而验证阶段、准备阶段、解析阶段、初始化阶段都是用 JVM 来处理的。<br>整个类加载是在Java 中一个叫做类加载器上进行的，如果我们能程序更改后，让程序所在的进程能够实时的获取到编译后的Class类字节码信息，然后重新加载的话，那么就可以实现热加载功能。</p><h3 id="Java-类加载器"><a href="#Java-类加载器" class="headerlink" title="Java 类加载器"></a>Java 类加载器</h3><p>类加载器，顾名思义就是加载Java类的工具，Java默认设置了三个类加载器。</p><ul><li>BootstrapClassloader</li><li>ExtClassloader</li><li>AppClassloader  </li></ul><p>BootstrapClassloader 叫做启用类加载器，用于加载JRE核心类库，使用C++实现。加载路径%JAVA_HOME%/lib下的所有类库。  </p><p>ExtClassloader 扩展类加载器，加载%JAVA_HOME%/lib/ext中的所有类库。  </p><p>AppClassloader 应用类加载器也叫系统类加载器System Classloader，加载%CLASSPATH%路径下的所有类库。</p><p>Java 也提供了扩展，可以让我们自己实现类加载的功能。类加载器在Java中是<code>java.lang.ClassLoader</code>这个类，如果要自定义类加载器，只要实现这个类，重写加载方法就好了。</p><p>在Java中，由不同的类加载器加载的两个相同的类在Java虚拟机里是两个不同的类，那么Java是怎么确保一个类不会被多个类加载器重复加载，并且保证核心API不会被篡改的呢？  </p><p>这就需要Java的双亲委派机制。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="/2021/12/29/hot-loading/classloader.png" alt="classloader"></p><p>当一个类加载器接到加载类的请求后，首先会交给父类去加载，如果所有父类都无法加载，自己加载，并将被加载的类缓存起来。。</p><p>每加载一个类，所有的类加载器都会判断是否可以加载，最终会委托到启动类加载器来首先加载。所有的类的加载都尽可能由顶层的类加载器加载，这样就保证了加载的类的唯一性。  </p><p>启动类加载器、扩展类加载器、应用程序类加载器，都有自己加载的类的范围，因此并不是所有的类父类都可以加载。</p><p>Java 类加载器中还有一个全盘委托机制，当指定一个<code>ClassLoader</code>加载一个类时，该类所依赖或者引用的类也会由这个类加载器来加载，除非显示的用别的类加载器加载。</p><p>比如：程序入口默认用的是<code>AppClassloader</code>，那么以后创建出来的类也是用<code>AppClassloader</code>来加载，除非自己显示的用别的类加载器去加载。</p><h3 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h3><p>OK，有了以上铺垫，现在可以来实现热加载的功能了，怎么实现呢？  </p><p>1、首先要实现自己的类加载器，破坏双亲委派机制。<br>2、通过自定义的类加载器加载所需的类。<br>3、不断的轮询判断类是否有变化，如果有变化重新加载。</p><p>自定义类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUFFIX = <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String rootPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootPath = rootPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 破坏双亲委派机制,自定义类加载方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == loadedClass) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> findClass(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadedClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String path = rootPath + name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + SUFFIX;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classBytes = getClassBytes(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != classBytes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">super</span>.findLoadedClass(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.findLoadedClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; aClass = defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != aClass) &#123;</span><br><span class="line">                <span class="keyword">return</span> aClass;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fileInputStream.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel writableByteChannel = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> read = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (read == <span class="number">0</span> || read == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            by.flip();</span><br><span class="line">            writableByteChannel.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器重写了<code>loadClass()</code>方法和<code>findClass</code>方法，破坏了Java的双亲委派机制，先通过自定义的类加载所需的类，如果加载不到，再交给父类加载。  </p><p>接下来，写启动器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String rootPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        rootPath = cl.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(rootPath);</span><br><span class="line">        startFileListener(rootPath);</span><br><span class="line">        start0(myClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startFileListener</span><span class="params">(String rootPath)</span> </span>&#123;</span><br><span class="line">        FileAlterationObserver fileAlterationObserver = <span class="keyword">new</span> FileAlterationObserver(rootPath);</span><br><span class="line">        fileAlterationObserver.addListener(<span class="keyword">new</span> FileListener());</span><br><span class="line">        FileAlterationMonitor fileAlterationMonitor = <span class="keyword">new</span> FileAlterationMonitor(<span class="number">5</span>);</span><br><span class="line">        fileAlterationMonitor.addObserver(fileAlterationObserver);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileAlterationMonitor.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">(MyClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = classLoader.findClass(<span class="string">&quot;com.example.Run&quot;</span>);</span><br><span class="line">            clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟启动应用程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Application application = <span class="keyword">new</span> Application();</span><br><span class="line">        application.printApplicationName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run()</code> 方法是入口，首先自定义了加载器，然后设置了文件监听，这个文件监听用的是<code>commons-io</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>最后调用<code>start0</code>来启动项目，在<code>start0</code>里通过自定义的类加载器又重新加载了<code>Run</code>本身，然后通过反射调用<code>start()</code>方法，<code>start()</code>方法里启动真正的项目。这样的目的是因为类加载器中的全盘委托机制。Java 默认用的是<code>AppClassloader</code>，所以只能显示的通过自定义的类加载器来加载启动类，再启动真正的项目。</p><p>文件的监听，使用<code>commons-io</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListener</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">        <span class="keyword">if</span> (file.getName().indexOf(<span class="string">&quot;.class&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(Run.rootPath);</span><br><span class="line">                Run.start0(myClassLoader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onFileCreate(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">        <span class="keyword">if</span> (file.getName().indexOf(<span class="string">&quot;.class&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(Run.rootPath);</span><br><span class="line">                Run.start0(myClassLoader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过监听文件的创建和修改，如果文件有变化，定义一个新的类加载器，重新运行项目。</p><p>模拟的真正项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printApplicationName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;应用程序777&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好了，现在来测试一下项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Run.run(Main.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置一下idea，让编译器可以自动编译<br><img src="/2021/12/29/hot-loading/classloader.png" alt="idea"></p><p>现在修改<code>Application</code>里<code>printApplicationName</code>输出的内容，等编译器编译完后，可以看到修改的内容了。</p><p>本文只是一个供学习使用的简单小小的例子，项目github地址：<a href="https://github.com/yaocl0/hot-loading">https://github.com/yaocl0/hot-loading</a></p>]]></content>
    
    
    <summary type="html">热加载是指在不重启服务的情况下使更改的代码生效。注意和热部署的区别，热加载主要是在开发环境下使用。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊Tomcat 系统架构设计</title>
    <link href="http://yaocl.cn/2021/12/22/tomcat-arch/"/>
    <id>http://yaocl.cn/2021/12/22/tomcat-arch/</id>
    <published>2021-12-22T09:22:09.000Z</published>
    <updated>2023-05-22T01:00:59.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>Tomcat 是一个应用服务器，那么要开发一个应用服务器，首先捋一捋它的需求，要实现那些功能。</p><p>1、 首先可以和客户端建立连接，并且能够处理客户端的连接</p><p>2、 其次还要解析处理我们写的 Servlet</p><p>3、 最后能够根据客户端的请求找到相应的 Servlet。</p><p>在 Tomcat 中将这些需求分为了两大功能</p><ul><li>处理 Socket 连接，并将网络字节流转换成 Request 对象和 Response 对象</li><li>解析、加载和管理 Servlet，处理请求并返回响应数据</li></ul><p>Tomcat 将这两大功能，设计成了两个主要的组件</p><ul><li>连接器（Connector）</li><li>容器（Container）</li></ul><p>来看一下 Tomcat 的总体架构</p><p><img src="/2021/12/22/tomcat-arch/all.png" alt="all"></p><p>上图中是 Tomcat 的整体架构，一个 Tomcat 代表一个 Server，一个 Server 下包含对个 Service，每个 Service 下包含多个连接器和一个容器。</p><p>Service 本身没有什么重要的作用，它只是把连接器和容器组装在一起了，但是 Tomcat 可以同时设置多个 Service，也就可以部署多个服务。比如有两个相同的项目，可以把这两个项目放到两个 Service 里，那这两个相同的项目就可以在一个 Tomcat 里运行了，不用担心冲突的问题。</p><p>这些配置可以在 conf/server.xml 中查看。</p><p>接下来重点关注一下连接器和容器，这是 Tomcat 工作的核心。</p><h4 id="连接器（Connector）"><a href="#连接器（Connector）" class="headerlink" title="连接器（Connector）"></a>连接器（Connector）</h4><p>在分析连接器之前，先了解一下 Tomcat 支持的 I/O 模型和应用层协议。</p><p>I/O 模型：</p><ul><li>NIO：非阻塞 I/O， Java NIO 类库实现。</li><li>NIO2：异步 I/O， JDK 7 最新的 NIO2 类库实现。</li><li>APR： Apache 可移植运行库实现，是 C/C++ 编写的本地库。</li></ul><p>应用层协议：</p><ul><li>HTTP/1.1</li><li>AJP：用于和 Web 服务器集成（如 Apache）。</li><li>HTTP/2：HTTP 2.0 大幅度的提升了 Web 性能。</li></ul><p>Service 中存在多个连接器就是为了支持 Tomcat 的多个 I/O 模型和应用层协议。</p><p>OK，现在来分析连接器。</p><p>首先可以先看一看 Tomcat 中连接器的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;24100&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">&quot;on&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compressionMinSize</span>=<span class="string">&quot;2048&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">noCompressionUserAgents</span>=<span class="string">&quot;gozilla, traviata&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compressableMimeType</span>=<span class="string">&quot;text/html,text/xml,text/javascript,text/css,text/plain,image/jpeg,image/gif&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>连接器中配置了监听的端口和使用的应用层协议等信息。</p><p>在上面说了，连接器的主要作用是处理 Socket 连接，并将网络字节流转换成 Request 对象和 Response 对象。那么我可以再试着捋一捋连接器的需求</p><p>1、 监听端口</p><p>2、 建立连接</p><p>3、 获取客户端传输的字节流</p><p>4、 根据应用层协议解析字节流，将解析的数据交给容器处理</p><p>5、 容器返回响应</p><p>6、 将响应转换成字节流返回给客户端</p><p>根据以上的需求，Tomcat 将整个连接器分为了三部分</p><ul><li>网络通信</li><li>解析应用层协议</li><li>与容器进行交互</li></ul><p>Tomcat 将这三个功能分成了三个模块：Endpoint、Processor 和 Adapter，三个模块只通过抽象接口进行交互，封装了变化，降低了耦合度。</p><p>三个模块的处理逻辑为：  </p><p>1、Endpoint 接收字节流，并交给 Processor。  </p><p>2、Processor 拿到字节流后，将字节流解析成 Tomcat Request 对象并交给 Adapter。  </p><p>3、Adapter 拿到 Tomcat Request 对象再解析成 ServletRequest 交给容器。  </p><p>Tomcat 并没有直接将字节流解析成 ServletRequest 而是先解析成了 Tomcat Request，再通过 Adapter 进行转换，这样做的好处可以使连接器和容器接偶，我们可以自己实现 Adapter 的功能，来对接我们自己实现的类似容器的功能。</p><p>由于 Tocmat 支持多种 I/O 模型和应用层协议，并且这些 I/O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO2 + AJP。Tomcat 设计了一个 ProtocolHandler，将网络通信和解析应用层协议放到了一起，来封装这两点的变化。</p><p>来看一下连接器的结构图</p><p><img src="/2021/12/22/tomcat-arch/connector.png" alt="connector"></p><p>来看一下连接器各个组件的代码结构</p><h5 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h5><p>Endpoint 不是一个接口，只有对应的实现类 AbstractEndpoint</p><p><img src="/2021/12/22/tomcat-arch/Endpoint.png" alt="Endpoint"></p><p>AbstractEndpoint 的实现类中包含了 Tomcat 支持的 I/O 模型。</p><h5 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h5><p><img src="/2021/12/22/tomcat-arch/Processor.png" alt="Processor"></p><p>Processor 的实现类是包含了 Tomcat 支持的所有应用协议。</p><h5 id="ProtocolHandler"><a href="#ProtocolHandler" class="headerlink" title="ProtocolHandler"></a>ProtocolHandler</h5><p><img src="/2021/12/22/tomcat-arch/ProtocolHandler.png" alt="ProtocolHandler"></p><p>ProtocolHandler 的实现类里包含了每一种 I/O 模型和协议的组合。</p><h5 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h5><p>Adapter 只有一个实现类 CoyoteAdapter，CoyoteAdapter 是一个典型的适配器模式的使用，ProtocolHandler 中将不同的 IO 模式和不同的应用层协议通过 Endpoint 和 Processor 封装成 Tomcat Request，这个 Request 在 Adapter 中转换成标准的 ServletRequest。这其实也是一个扩展点，我们可以实现自己的 Adapter，拿到 Request 进行自己的业务处理，甚至可以不用 Servlet 那一套，自己定义一套新的应用处理模式。</p><h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><p>容器的作用是解析、加载和管理 Servlet，处理请求并返回响应数据。在 Tomcat 中设计了四种容器 Engine、Host、Context 和 Wrapper，这四种容器是父子关系。</p><ul><li><p>Engine 表示引擎，用来管理多个虚拟站点</p></li><li><p>Host 代表的是一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址</p></li><li><p>Context 表示一个 Web 应用程序，也是就我们写的一个项目</p></li><li><p>Wrapper 表示一个 Servlet</p></li></ul><p>一个 Service 最多只能有一个 Engine，一个 Engine 中可以包含多个 Host，一个 Host 中可以包含多个个 Context，一个 Context 可以包含多个 Wrapper</p><p>看一下它的结构图</p><p><img src="/2021/12/22/tomcat-arch/Container.png" alt="Container"></p><p>可以结合 conf/server.xml 配置文件来理解容器的设计</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--连接器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tomcat 容器是怎么确定请求的是那个 Servlet 的呢？</p><p>通过一个例子来说明一下，图片是盗来的，哈哈哈哈。</p><p><img src="/2021/12/22/tomcat-arch/demo.png" alt="demo"></p><p>上面这个例子中，要访问 <code>http://user.shopping.com:8080/order/buy</code>。  Tomcat通过连接器解析数据后，交给容器，</p><p>1、 根据域名找到对应的 Host，也就是在 conf/server.xml 中配置的和 Host 的 name 相同的 Host</p><p>2、根据 URL 找到 Context</p><p>3、根据 URL 找到 Wrapper（Servlet）</p><p>当连接器将数据给到容器后，并不是直到找到 Servlet 才开始处理数据，容器的每一层都会对数据进行一些处理。Tomcat 用了一个叫做 Pipeline-Valve 管道的方式来对数据进行处理。</p><h5 id="Pipeline-Valve-管道"><a href="#Pipeline-Valve-管道" class="headerlink" title="Pipeline-Valve 管道"></a>Pipeline-Valve 管道</h5><p>Pipeline-Valve 管道是一种责任链模式，其中 Valve 表示一个处理点，Pipeline 中包含多个 Valve，每个容器中包含一个 Pipeline，每个容器中的 Pipeline 必须包含一个 BasicValve，处于调用的最末端，负责调用下个容器的 Value。</p><p>用一张图来解释一下</p><p><img src="/2021/12/22/tomcat-arch/Pipeline-Valve.png" alt="Pipeline-Valve"></p><p>Wrapper 容器的最后一个 Valve 会创建一个 Filter 链，并调用 doFilter 方法，最终会调到 Servlet 的 service 方法。</p><p>来看一下容器的代码结构</p><p>Tomcat 设计了一个顶层的容器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Container <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Container container)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Container child)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ....省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个容器继承了这个顶层的容器</p><p><img src="/2021/12/22/tomcat-arch/ContainerClass.png" alt="ContainerClass"></p><p><code>Container</code>中定义了操作父容器和子容器的方法，很明显的组合模式。</p><p>再来看看每个实现类的结构</p><p><img src="/2021/12/22/tomcat-arch/standContainerClass.png" alt="standContainerClass"></p><p>每个类同时又继承了一个 Container 的实现抽象类<code>ContainerBase</code>，看一下这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBase</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Pipeline pipeline = <span class="keyword">new</span> StandardPipeline(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ContainerBase 中有<code>Pipeline</code>的属性，这就是 Pipeline-Valve 管道。</p><p>OK，最后结合Java类来看看Tomcat组件的总体结构。  </p><p><img src="/2021/12/22/tomcat-arch/class.png" alt="class"></p>]]></content>
    
    
    <summary type="html">Tomcat 是一个应用服务器，那么要开发一个应用服务器，首先捋一捋它的需求，要实现那些功能。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="Tomcat" scheme="http://yaocl.cn/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型中的类型擦除以及Type接口</title>
    <link href="http://yaocl.cn/2021/11/15/type-erasure/"/>
    <id>http://yaocl.cn/2021/11/15/type-erasure/</id>
    <published>2021-11-15T08:18:29.000Z</published>
    <updated>2023-05-22T01:00:59.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java 泛型（generics）是JDK1.5中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题;其所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。  </p></blockquote><p>但是在Java中并不是真正的泛型，实际上是“伪泛型”</p><h3 id="类型擦除（type-Erasure）"><a href="#类型擦除（type-Erasure）" class="headerlink" title="类型擦除（type Erasure）"></a>类型擦除（type Erasure）</h3><p>为了与之前的版本兼容，JDK1.5中通过类型擦除来增加的泛型功能。Java泛型只是在编译器层次上，在编译后生成的字节码中是不包含泛型中类型的信息的。<br>通过一个例子来证明类型擦除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; sList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; iList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        System.out.println(sList.getClass() == iList.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了两个ArrayList，一个是ArrayList&lt;String&gt;泛型类型的,一个是ArrayList&lt;Integer&gt;类型的，但是最后打印的是<code>true</code>，说明两个类型相同。<br>用<code>javap -c</code>看一下生成的生成的字节码</p><p><img src="/2021/11/15/type-erasure/1.png" alt="1"></p><p>可以看到在字节码中，ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;都被编译成了ArrayList类型，可见编译后发生了类型擦除。</p><ol><li>既然编译后发生了类型擦除，那么虚拟机解析、反射等场景是怎么获取到正确的类型的？   </li></ol><p>在JDk1.5中增加泛型的同时，JCP组织修改了虚拟机规范，增加了<code>Signature</code>、<code>LocalVariableTypeTable</code>新属性。<br>用<code>javap -v</code>查看一下字节码，在<code>main</code>方法中包含一段<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTypeTable:</span><br><span class="line">  Start  Length  Slot  Name   Signature</span><br><span class="line">    8      31     1 sList   Ljava/util/ArrayList&lt;Ljava/lang/String;&gt;;</span><br><span class="line">    16      23     2 iList   Ljava/util/ArrayList&lt;Ljava/lang/Integer;&gt;;</span><br></pre></td></tr></table></figure><br> <code>LocalVariableTypeTable</code>是一个可选属性，如果存在泛型，则会出现这个属性。在<code>Signature</code>下包含了泛型的信息。</p><ol start="2"><li>接下来，看这段代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; sList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">sList.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">String s = sList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>类型擦除之后，当调用<code>sList.get(0)</code>是如何确保返回的值不会和String不匹配呢？<br>用<code>javap -c</code>查看一下字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class com.example.demo.test.main &#123;</span><br><span class="line">       // .....省略</span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.NoSuchFieldException;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #4                  // String 111</span><br><span class="line">      11: invokevirtual #5                  // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z</span><br><span class="line">      14: pop</span><br><span class="line">      15: aload_1</span><br><span class="line">      16: iconst_0</span><br><span class="line">      17: invokevirtual #6                  // Method java/util/ArrayList.get:(I)Ljava/lang/Object;</span><br><span class="line">      20: checkcast     #7                  // class java/lang/String</span><br><span class="line">      23: astore_2</span><br><span class="line">      24: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>#7</code>处有一个<code>checkcast</code>指令，<code>checkcast</code>用于检查类型强制转换是否可以进行，也就是泛型在获取值的时候进行了强制类型转换。</p><ol start="3"><li>再来看看下面这段代码  </li></ol><p>首先定义一个Java泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个子类继承它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassTest</span> <span class="keyword">extends</span> <span class="title">GenericClass</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>GenericClassTest</code>中将<code>GenericClass</code>的泛型定义为<code>Integer</code>类型，并重写了get和set方法，因为存在类型擦除，父类<code>GenericClass</code>的泛型被擦除了。<br>用<code>javap -c</code> 查看一下<code>GenericClass</code>编译后的字节码</p><p><img src="/2021/11/15/type-erasure/2.png" alt="2"></p><p>可以看到类型擦除后泛型变为了<code>Object</code>。那么<code>GenericClass</code>也就变为了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，父类<code>GenericClass</code>中set和get方法操作的是Object对象，而子类<code>GenericClassTest</code> 操作的是Integer对象，为什么还可以重写？按照正常的继承关系中，这应该是重载。<br>按照重载的方式试一下</p><p><img src="/2021/11/15/type-erasure/3.png" alt="3"></p><p>可以看到设置Object对象出现了红波浪线，不允许这样设置，看来确实是重写，而不是重载。为什么会时重写，这不是跟Java多态冲突么？继续往下研究。<br>现在用<code>javap -c</code>看一下子类<code>GenericClassTest</code>的字节码文件</p><p><img src="/2021/11/15/type-erasure/4.png" alt="4"></p><p>在<code>GenericClassTest</code>中get和/set方法都有两个，一个是操作Object对象一个是操作Integer对象。<br>操作Integer对象的是<code>GenericClassTest</code>定义的，操作Object对象的是由编译器生成的。<br>再用<code>javap -v</code> 查看一下字节码更详细的信息。</p><p><img src="/2021/11/15/type-erasure/5.png" alt="5"></p><p>编译器生成的两个操作Object对象的方法中多了两个<code>ACC_BRIDGE</code>、<code>ACC_SYNTHETIC</code>标志。<br>这就是虚拟机解决类型擦除和多态冲突问题的方法：使用<code>桥接方法</code>。<br><code>桥接方法</code>方法是由编译器生成的，我们在代码中并不能直接使用，但是可以通过反射拿到桥接方法再使用。</p><p>泛型一旦编译过后，类型就被擦除了，那到了运行时，怎么获取泛型信息？这就要使用JDK提供的Type类型接口了。</p><h3 id="Type类型"><a href="#Type类型" class="headerlink" title="Type类型"></a>Type类型</h3><p>在没有泛型之前，所有的类型都通过Class类进行抽象，Class类的一个具体对象就代表了一个类型。<br>在JDK1.5增加了泛型之后，扩充了数据类型，将泛型也包含了。<br>JDK在原来的基础上增加了一个<code>Type</code>接口，它是所有类型的父接口，它的子类有</p><ul><li><code>Class</code>类： 原始/基本类型，包括平时我们所有的类、枚举、数组、注解，还有int、float等基本类型</li><li><code>ParameterizedType</code>接口：参数化类型，比如List&lt;String&gt;</li><li><code>TypeVariable</code>接口：类型变量，比如List&lt;T&gt;中的T就是参数化变量</li><li><code>GenericArrayType</code>接口： 数组类型，比如List&lt;String&gt;[]、T[]</li><li><code>WildcardType</code>接口：泛型表达式类型，比如List&lt; ? extends Number&gt;</li></ul><h4 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a>ParameterizedType</h4><p>参数化类型，即带有参数的类型，也就是带有&lt;&gt;的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getActualTypeArguments()</code>: 获取类型内部的参数化类型 比如Map&lt;K,V&gt;里面的K，V类型。</li><li><code>getRawType()</code>: 类的原始类型，比如Map&lt;K,V&gt;中的Map类型。</li><li><code>getOwnerType()</code>: 获取所有者类型（只有内部类才有所有者，比如Map.Entry他的所有者就是Map），若不是内部类，此处返回null。  </li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; tList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;GenericClass&gt; genericClassClass = GenericClass.class;</span><br><span class="line">        Field[] declaredFields = genericClassClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            Type genericType = declaredField.getGenericType();</span><br><span class="line">            <span class="keyword">if</span> (genericType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========&quot;</span> + genericType.getTypeName() + <span class="string">&quot;======ParameterizedType类型=====&quot;</span>);</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) genericType;</span><br><span class="line">                System.out.println(<span class="string">&quot;getActualTypeArguments:&quot;</span>);</span><br><span class="line">                Type[] actualTypeArguments = (parameterizedType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;    &quot;</span> + actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">                Type rawType = (parameterizedType).getRawType();</span><br><span class="line">                System.out.println(<span class="string">&quot;getRawType:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;    &quot;</span> + rawType);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">==========java.util.List&lt;java.lang.String&gt;======ParameterizedType类型=====</span><br><span class="line">getActualTypeArguments:</span><br><span class="line">    java.lang.String</span><br><span class="line">getRawType:</span><br><span class="line">    interface java.util.List</span><br><span class="line">==========java.util.List&lt;T&gt;======ParameterizedType类型=====</span><br><span class="line">getActualTypeArguments:</span><br><span class="line">    T</span><br><span class="line">getRawType:</span><br><span class="line">    interface java.util.List</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="TypeVariable"><a href="#TypeVariable" class="headerlink" title="TypeVariable"></a>TypeVariable</h4><p>类型变量，即泛型中的变量，例如：T、K、V等变量，可以表示任何类；</p><blockquote><p>注意: 与ParameterizedType的区别，TypeVariable代表着泛型中的变量，而ParameterizedType则代表整个泛型。比如List&lt;T&gt;中，T是TypeVariable类型，List&lt;T&gt;是ParameterizedType类型  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeVariable</span>&lt;<span class="title">D</span> <span class="keyword">extends</span> <span class="title">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span>, <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Type[] getBounds();</span><br><span class="line">    </span><br><span class="line">    <span class="function">D <span class="title">getGenericDeclaration</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// JDK8新增的</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getBounds()</code>：类型对应的上限，默认为Object  可以有多个。比如List&lt; T extends Number &amp; Serializable&gt;中的Number和Serializable</li><li><code>getGenericDeclaration()</code>： 获取声明该类型变量实体，比如GenericClass&lt; T&gt;中的GenericClass</li><li><code>getName()</code>：获取类型变量在源码中定义的名称；  </li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;GenericClass&gt; genericClassClass = GenericClass.class;</span><br><span class="line">        Field[] declaredFields = genericClassClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            Type genericType = declaredField.getGenericType();</span><br><span class="line">            <span class="keyword">if</span> (genericType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========&quot;</span> + genericType.getTypeName() + <span class="string">&quot;======TypeVariable类型=====&quot;</span>);</span><br><span class="line">                TypeVariable typeVariable = (TypeVariable) genericType;</span><br><span class="line">                Type[] bounds = typeVariable.getBounds();</span><br><span class="line">                System.out.println(<span class="string">&quot;getBounds：&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Type bound : bounds) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;    &quot;</span> + bound);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;getGenericDeclaration：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;    &quot;</span> + typeVariable.getGenericDeclaration());</span><br><span class="line">                System.out.println(<span class="string">&quot;getName：&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;    &quot;</span> + typeVariable.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==========T======TypeVariable类型=====</span><br><span class="line">getBounds：</span><br><span class="line">    class java.lang.Number</span><br><span class="line">getGenericDeclaration：</span><br><span class="line">    class com.example.demo.test.GenericClass</span><br><span class="line">getName：</span><br><span class="line">    T</span><br></pre></td></tr></table></figure><h4 id="GenericArrayType"><a href="#GenericArrayType" class="headerlink" title="GenericArrayType"></a>GenericArrayType</h4><p>泛型数组类型，用来描述ParameterizedType、TypeVariable类型的数组；例如：List&lt;T&gt;[] 、T[]、List&lt;String&gt;[]等。</p><blockquote><p>注意： GenericArrayType是来描述与泛型相关的数组，与String[]、int[]、float[]这种类型不同。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericArrayType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getGenericComponentType()</code>：返回泛型数组中元素的Type类型，比如List&lt;String&gt;[] 中的 List&lt;String&gt;  </li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt;[] lists;</span><br><span class="line">    <span class="keyword">private</span> T[] ts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;GenericClass&gt; genericClassClass = GenericClass.class;</span><br><span class="line">        Field[] declaredFields = genericClassClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            Type genericType = declaredField.getGenericType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (genericType <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">                GenericArrayType genericArrayType = (GenericArrayType) genericType;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========&quot;</span> + genericType.getTypeName() + <span class="string">&quot;======GenericArrayType类型=====&quot;</span>);</span><br><span class="line">                Type genericComponentType = genericArrayType.getGenericComponentType();</span><br><span class="line">                System.out.println(<span class="string">&quot;getGenericComponentType:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;    &quot;</span> + genericComponentType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==========java.util.List&lt;java.lang.String&gt;[]======GenericArrayType类型=====</span><br><span class="line">getGenericComponentType:</span><br><span class="line">    java.util.List&lt;java.lang.String&gt;</span><br><span class="line">==========T[]======GenericArrayType类型=====</span><br><span class="line">getGenericComponentType:</span><br><span class="line">    T</span><br></pre></td></tr></table></figure><h4 id="WildcardType"><a href="#WildcardType" class="headerlink" title="WildcardType"></a>WildcardType</h4><p>泛型表达式（通配符表达式）。例如：？ extend Number、？ super Integer。</p><blockquote><p>注意： WildcardType虽然是Type的子接口，但不代表一种类型，，表示的仅仅是类似 ? extends T、? super K这样的通配符表达式。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WildcardType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">Type[] getUpperBounds();</span><br><span class="line"> </span><br><span class="line">Type[] getLowerBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getUpperBounds()</code> 获得泛型表达式上界（上限） 获取泛型变量的上边界（extends)</li><li><code>getLowerBounds()</code> 获得泛型表达式下界（下限） 获取泛型变量的下边界（super）  </li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;? extends Number&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;? <span class="keyword">super</span> Integer&gt; integers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;GenericClass&gt; genericClassClass = GenericClass.class;</span><br><span class="line">        Field[] declaredFields = genericClassClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            Type genericType = declaredField.getGenericType();</span><br><span class="line">            <span class="keyword">if</span> (genericType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) genericType;</span><br><span class="line"></span><br><span class="line">                Type[] actualTypeArguments = (parameterizedType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(actualTypeArgument <span class="keyword">instanceof</span> WildcardType)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;==========&quot;</span> + actualTypeArgument.getTypeName() + <span class="string">&quot;======WildcardType类型=====&quot;</span>);</span><br><span class="line">                        WildcardType wildcardType = (WildcardType) actualTypeArgument;</span><br><span class="line">                        System.out.println(<span class="string">&quot;getUpperBounds:&quot;</span>);</span><br><span class="line">                        Type[] upperBounds = wildcardType.getUpperBounds();</span><br><span class="line">                        <span class="keyword">for</span> (Type upperBound : upperBounds) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;    &quot;</span>+ upperBound);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;getLowerBounds:&quot;</span>);</span><br><span class="line">                        Type[] lowerBounds = wildcardType.getLowerBounds();</span><br><span class="line">                        <span class="keyword">for</span> (Type lowerBound : lowerBounds) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;    &quot;</span>+ lowerBound);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==========? extends java.lang.Number======WildcardType类型=====</span><br><span class="line">getUpperBounds:</span><br><span class="line">    class java.lang.Number</span><br><span class="line">getLowerBounds:</span><br><span class="line">==========? super java.lang.Integer======WildcardType类型=====</span><br><span class="line">getUpperBounds:</span><br><span class="line">    class java.lang.Object</span><br><span class="line">getLowerBounds:</span><br><span class="line">    class java.lang.Integer</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java 泛型（generics）是JDK1.5中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题;其所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java函数式编程</title>
    <link href="http://yaocl.cn/2021/10/24/javalambda/"/>
    <id>http://yaocl.cn/2021/10/24/javalambda/</id>
    <published>2021-10-24T10:59:07.000Z</published>
    <updated>2023-05-22T01:00:59.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h4><p>函数式编程是一种编程范式，即一切都是数学函数。在Java面向对象编程中，程序是一系列相互作用（方法）的对象，而在函数式编程中，程序会是一个无状态的函数组合序列。</p><h4 id="函数是“第一等公民”"><a href="#函数是“第一等公民”" class="headerlink" title="函数是“第一等公民”"></a>函数是“第一等公民”</h4><p>“第一等公民”指的是函数和其他数据类型一样，处于平等的地位。可以赋值给变量、可以作为另一个函数的参数或者作为一个函数的返回值。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将两数相加的逻辑赋值给变量sum</span></span><br><span class="line"><span class="keyword">var</span> sum = (a,b)-&gt;a+b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数作为另一个函数的参数</span></span><br><span class="line">operation(sum)</span><br></pre></td></tr></table></figure><h3 id="Java函数试编程"><a href="#Java函数试编程" class="headerlink" title="Java函数试编程"></a>Java函数试编程</h3><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><p>历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。  </p><p>在Java中Lambda 表达式的表达形式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数)-&gt;方法体</span><br></pre></td></tr></table></figure><ol><li>参数：可以有多个，如果只有一个可以省略括号</li><li>-&gt;：箭头符号。</li><li>方法体：方法体超过一句时，要用{}包裹，可以根据情况看是否需要<code>return</code>语句</li></ol><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>Java 8提供了函数式编程接口的概念，用作Lambda表达式的类型。 </p><p>函数式接口：只定义了<em>单一抽象方法</em>的接口。  </p><p>举个例子，看一下Java 8中Runnable接口 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在类上多了一个<code>@FunctionalInterface</code>注解</p><p>Java 8之前定义一个Runnable 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Java 8之后可以直接写成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r =()-&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>@FunctionalInterface</code>注解并不是必须的，只要符合单一抽象方法的接口都可以。  </p><p>用一个加减乘除的例子来演示一下Java中函数式编程的使用。 </p><p>首先定义一个函数式接口，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将不同的逻辑操作赋值给函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加</span></span><br><span class="line">        Operate add = (a, b) -&gt; a + b;</span><br><span class="line">        <span class="comment">// 减</span></span><br><span class="line">        Operate subtract = (a, b) -&gt; a - b;</span><br><span class="line">        <span class="comment">// 乘</span></span><br><span class="line">        Operate multiply = (a, b) -&gt; a * b;</span><br><span class="line">        <span class="comment">// 除</span></span><br><span class="line">        Operate divide = (a, b) -&gt; a / b;</span><br><span class="line">        </span><br><span class="line">        System.out.println(operate(add, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(operate(subtract, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(operate(multiply, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(operate(divide, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(Operate operate, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operate.operate(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，加减乘除的每个变量是一个个的函数，具体的函数逻辑在等号的右边。同时定义了一个operate的方法，第一个参数是Operate类型函数式接口，也就是接收的是一个函数，然后运行函数的逻辑，实际上是运行等号右边的逻辑。</p><p>在Java 8中，<code>java.util.function</code>下定义了许多函数式接口。列一下几个核心的函数式接口</p><table><thead><tr><th>接口</th><th>参数</th><th>返回类型</th><th>表述</th></tr></thead><tbody><tr><td>Predicate<T></td><td>T</td><td>boolean</td><td>用于判断操作函数</td></tr><tr><td>Consumer<T></td><td>T</td><td>void</td><td>没有返回结果的函数</td></tr><tr><td>Function&lt;T, R&gt;</td><td>T</td><td>R</td><td>入参是T，出参是R的函数</td></tr><tr><td>Supplier<T></td><td></td><td>T</td><td>生成一个对象T的函数</td></tr><tr><td>UnaryOperator<T></td><td>T</td><td>T</td><td>入参、出参都是T的类型函数</td></tr><tr><td>BinaryOperator<T></td><td>(T,T)</td><td>T</td><td>接收两个入参为T，出参也为T的函数</td></tr></tbody></table><p>还是那上面加减乘除的例子，可以用<code>BinaryOperator</code>函数来表示,表示有两个入参是Integer出参也是Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;</span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; subtract = (a, b) -&gt; a - b;</span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; multiply = (a, b) -&gt; a * b;</span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; divide = (a, b) -&gt; a / b;</span><br></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法,方法引用的本质其实是简化Lambda 表达式。</p><p>方法引用的使用是一对冒号<code>::</code></p><table><thead><tr><th>类型</th><th>方法引用</th><th align="center">对应的Lambda表达式</th></tr></thead><tbody><tr><td>构造方法引用</td><td>类名::new</td><td align="center">(args) -&gt; new 类名(args)</td></tr><tr><td>静态方法引用</td><td>类名:: 静态方法名</td><td align="center">(args) -&gt; 类名.staticMethod(args)</td></tr><tr><td>实例方法引用</td><td>类名::方法名</td><td align="center">(inst,args) -&gt; inst.method(args)</td></tr><tr><td>对象方法引用</td><td>对象::方法名</td><td align="center">(args) -&gt; 对象.method(args)</td></tr></tbody></table><p>定义一个类来说明方法引用的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">equals</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName().equals(person.getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Supplier&lt;Person&gt; supplier = Person::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">//Lambda表达式写法</span></span><br><span class="line"> Supplier&lt;Person&gt; supplier = ()-&gt; <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p><code>用</code>Supplier函数式接口是因为调用的构造函数是无参的，符合Supplier函数式接口的定义</p><p><code>注意：被调用的方法的参数列表和返回值类型需要与函数式接口中抽象方法的参数列表和返回值类型要一致。</code></p><h4 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; say = Person::say;</span><br><span class="line"><span class="comment">//Lambda表达式写法</span></span><br><span class="line">Consumer&lt;Person&gt; say = person -&gt; Person.say(person); </span><br></pre></td></tr></table></figure><p>用Consumer函数式接口是因为say方法是一个包含一个参数，并且没有返回值的函数，符合Consumer函数式接口的定义</p><p>注意：被调用的方法的参数列表和返回值类型需要与函数式接口中抽象方法的参数列表和返回值类型要一致。</p><h4 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiConsumer&lt;Person, Person&gt; personPersonBiConsumer = Person::equals;</span><br><span class="line"><span class="comment">//Lambda表达式写法</span></span><br><span class="line">BiConsumer&lt;Person, Person&gt; personPersonBiConsumer = (inst, args) -&gt; inst.equals(args);</span><br></pre></td></tr></table></figure><p>实例方法引用第一个参数是实例方法的调用者，第二个是实例方法的参数。</p><p><code>注意：被调用的方法的参数列表和返回值类型需要与函数式接口中抽象方法的参数列表和返回值类型要一致。</code></p><h4 id="对象方法引用"><a href="#对象方法引用" class="headerlink" title="对象方法引用"></a>对象方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Consumer&lt;String&gt; eat = person::eat;</span><br><span class="line"><span class="comment">// Lambda表达式写法</span></span><br><span class="line">Consumer&lt;String&gt; eat = food -&gt; person.eat(food);</span><br></pre></td></tr></table></figure><p><code>注意：被调用的方法的参数列表和返回值类型需要与函数式接口中抽象方法的参数列表和返回值类型要一致。</code></p>]]></content>
    
    
    <summary type="html">函数式编程是一种编程范式，即一切都是数学函数。在Java面向对象编程中，程序是一系列相互作用（方法）的对象，而在函数式编程中，程序会是一个无状态的函数组合序列。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>HashMap那些事儿</title>
    <link href="http://yaocl.cn/2021/09/30/hashmap/"/>
    <id>http://yaocl.cn/2021/09/30/hashmap/</id>
    <published>2021-09-30T01:58:58.000Z</published>
    <updated>2023-05-22T01:00:59.066Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 在 Java 中是一个使用高频的数据结构，JDK1.8 以后 HashMap 进行了一次翻天覆地的改变。</p><p>本文基于 JDK1.8 分析一下 HashMap</p><h3 id="存储结构转换"><a href="#存储结构转换" class="headerlink" title="存储结构转换"></a>存储结构转换</h3><p>在 JDK1.8 以前 HashMap 采用的是<code>数组+链表</code>的结构，JDK1.8 以后又引入了红黑树的结构，会在链接和红黑树之间转换，结合源码分析一下 HashMap 对<code>数组+链表</code>和<code>数组+红黑树</code>的转换<br>首先看一下数据的存储结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> HashMap.Node&lt;K, V&gt;[] table;</span><br></pre></td></tr></table></figure><p>HashMap 定义了一个 Node 的数组，Node 的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      HashMap.Node&lt;K, V&gt; next;</span><br><span class="line">      <span class="comment">// ....省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 中包含了四个属性<code>hash</code>、<code>key</code>、<code>value</code>、<code>next</code>。</p><ul><li><code>key</code>、<code>value</code>是调用 HashMap 的<code>put()</code>方法传进来的。</li><li><code>hash</code> 是判断 key 是否重复的关键</li><li><code>next</code> 用于构建链表</li></ul><p>所以 HashMap 默认是一个<code>数组+链表</code>的形式</p><p><img src="/2021/09/30/hashmap/list.png" alt="list"></p><p><code>链表</code>是否要转换成<code>红黑树</code>，是在调用<code>put()</code>方法添加数据时判断的，跟着源码分析<code>链表</code>转换成<code>红黑树</code>的过程</p><p><code>put()</code>方法调用的是<code>putVal()</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = ((HashMap.Node) p).next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ((HashMap.Node) p).next = <span class="keyword">this</span>.newNode(hash, key, value,(HashMap.Node) <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((((HashMap.Node) e).hash == hash) &amp;&amp;</span><br><span class="line">                (((k = ((HashMap.Node) e).key) == key) ||</span><br><span class="line">                ((key != <span class="keyword">null</span>) &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = e;</span><br><span class="line">        ++binCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无关的部分省略了，while 循环中遍历链表中的数量，如果数量大于等于 8，调用<code>treeifyBin()</code>方法，<br>在<code>treeifyBin()</code>中有一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hd.treeify(tab);</span><br></pre></td></tr></table></figure><p><code>treeify()</code>方法会将<code>链表</code>转换为<code>红黑树</code>。同时会将链表中所有节点由<code>Node</code>结构转换为<code>TreeNode</code>结构。</p><p><code>TreeNode</code>继承自<code>java.util.LinkedHashMap.Entry</code>，<code>java.util.LinkedHashMap.Entry</code>又继承自<code>Node</code></p><p>那么<code>Node</code>就是<code>TreeNode</code>的父类，所以这样转换是不会有问题的。</p><p>经过<code>treeifyBin()</code>后存储结构变为<br><img src="/2021/09/30/hashmap/tree.png" alt="tree"></p><h3 id="put-方法的具体逻辑"><a href="#put-方法的具体逻辑" class="headerlink" title="put 方法的具体逻辑"></a>put 方法的具体逻辑</h3><p><code>put</code>方法中可以划分为 4 个部分，看一下方法的执行流程图。<br><img src="/2021/09/30/hashmap/put.png" alt="put"></p><p>结合一下源码<br><img src="/2021/09/30/hashmap/put-source.png" alt="put-source"></p><p>结合流程图和源码，对 put 的过程做一个描述<br>①：判断 tab 是否为空，如果为空说明 table 还未初始化，先对数组进行初始化<br>②：先计算在数组中的位置，并判断该位置是否为空，如果为空，则直接赋值。然后跳转到⑥<br>③: 判断节点 key 是否存在，如果存在直接额赋值，不存在则执行 ④<br>④：判断是否是红黑树，如果是则添加到树中，否则进入到⑤<br>⑤：为链表的情况，判断长度是否大于等于<code>TREEIFY_THRESHOLD - 1</code>，如果是，先将链表转花为红黑树，然后添加到树中。如果不是直接添加到列表中。<br>⑥：插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当 HashMap 键值对大于阀值时或者初始化时，会进行扩容。<br>阀值是<code>threshold</code>的值，是由数组的长度和<code>loadFactor(默认值是0.75)</code>决定的，threshold = length * loadFactor</p><p>HashMap 的扩容是在<code>resize()</code>方法里进行的，结合源码分析一下 HashMap 是怎么扩容的，因为 JDk1.8 引入了红黑数，所以代码比较长，就不贴全部的代码了，主要分析一下关键步骤。<br>先看一下初始化的几个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//现在容器的大小</span></span><br><span class="line"><span class="keyword">int</span> oldThr = threshold; 现在的阀值</span><br><span class="line"> <span class="keyword">int</span> newCap  <span class="comment">//计算过后，新的容器的大小</span></span><br><span class="line">     , newThr = <span class="number">0</span>; <span class="comment">//计算后阀值的大小</span></span><br></pre></td></tr></table></figure><p><code>注意： 扩容不只是改变容器的大小，还要改变阀值的大小</code></p><h4 id="1-table-容器不为空的情况"><a href="#1-table-容器不为空的情况" class="headerlink" title="1. table 容器不为空的情况"></a>1. table 容器不为空的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (oldCap &gt;=  MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数量已经大于最大的容量，则将阀值设置为整数最大值，不再扩容</li><li><code>newCap = oldCap &lt;&lt; 1</code> 扩容后仍然小于最大容量 并且 oldCap 大于默认值 16，双倍扩容阀值 threshold</li></ul><h4 id="2-旧的容量为-0，但-threshold-大于零"><a href="#2-旧的容量为-0，但-threshold-大于零" class="headerlink" title="2. 旧的容量为 0，但 threshold 大于零"></a>2. 旧的容量为 0，但 threshold 大于零</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">   newCap = oldThr;</span><br></pre></td></tr></table></figure><p>出现这种情况说明有参构造有 initialCapacity 传入，那么 threshold 已经被初始化成最小 2 的 n 次幂，所以直接将该值赋给新的容量</p><h4 id="3-旧的容量为-0，threshold-也等于-0"><a href="#3-旧的容量为-0，threshold-也等于-0" class="headerlink" title="3. 旧的容量为 0，threshold 也等于 0"></a>3. 旧的容量为 0，threshold 也等于 0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">     newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种情况说明是通过无参构造函数创建的，也就是<code>Map map = new HashMap()</code>这种格式，那么都被赋予默认的大小（默认 16）和默认的阈值（默认 16 * 0.75）</p><h4 id="4、-计算新的阈值"><a href="#4、-计算新的阈值" class="headerlink" title="4、 计算新的阈值"></a>4、 计算新的阈值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况说明是在有参构造时，默认的<code>loadFactor</code>被重新赋值，如果<code>loadFactor</code>大于 1，那么阈值会比容量大，有可能会超出最大容量，所以要重新计算。<br>还有一种情况在第一步中<code>newThr = oldThr &lt;&lt; 1</code>，左移超出范围后会置0，也要重新计算。</p><p>扩容也就这些了，剩下的代码是扩容后，元素重新排列的逻辑了。</p><p><code>注意：扩容的大小 （newCap = oldCap &lt;&lt; 1） &lt;&lt; 相当于乘2,所以HashMap的容量总是2的n次方</code></p><h3 id="确定key在数组中的位置"><a href="#确定key在数组中的位置" class="headerlink" title="确定key在数组中的位置"></a>确定key在数组中的位置</h3><p>在调用<code>put()</code>方法添加新数据时，在<code>put()</code>方法内部，调用<code>hash()</code>操作key，得到一个hash值<br><img src="/2021/09/30/hashmap/hash.png" alt="hash"></p><p>在<code>putVal()</code>方法中，在第②步的时候确定key在数组中的位置</p><p><img src="/2021/09/30/hashmap/index.png" alt="index"></p><p><code>hash()</code>方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在key等于null的情况下，会直接放到0处，不为null时，获取key的<code>hashCode</code>后，将<code>hashCode</code>的高16位和低16位进行异或。  </p><p>获取位置的整个过程有两个问题：</p><ol><li><code>(n - 1) &amp; hash</code> 是怎么获取到位置的？<br> <code>n</code>是table数组的长度，而数据的长度又总是2的n次方，所以<code>(n - 1) &amp; hash</code>正好是对n取模。<br> <code>( (n - 1) &amp; hash) ) == (hash % n)</code>, 这是一个非常巧妙的设计，用&amp;比%具有更高的效率。</li><li>将<code>hashCode</code>的高16位和低16位进行异或的作用是什么？<br> <code>hashCode</code>是一个int类型的数据，占4个字节 32位，而在HashMap中默认的长度是<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）</code>，要远小于int类型的范围，如果直接用<code>hashCode</code>进行运算，那么<code>hashCode</code>的高位部分对结果来说不会起太大作用，这样会增加hash碰撞的概率。所以用高16位和低16位进行异或来降低hash冲突的概率</li></ol><h3 id="使用任意类作为key的情况"><a href="#使用任意类作为key的情况" class="headerlink" title="使用任意类作为key的情况"></a>使用任意类作为key的情况</h3><p>HashMap判断key的位置是基于<code>hashCode</code>，如果要使用任意类作为key，必须要考虑是否要重写<code>hashCode</code>方法。默认的<code>hashCode</code>返回对象的是对象地址，直接使用使用可能会有问题。用伪代码举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...省略get set方法</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  User user1 = <span class="keyword">new</span> User();</span><br><span class="line">  user1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  user1.setAge(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  User user2 = <span class="keyword">new</span> User();</span><br><span class="line">  user2.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  user3.setAge(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Map&lt;User,Stirng&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  map.put(user1,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  map.put(user2,<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种情况下尽管user1和user2的属性都相同，但是user2并不会覆盖user1,因为user1和user2是两个对象，地址不相同，<code>hashCode</code>也不相同。  </p><blockquote><p>注意： 重写hashCode()方法时，要注意equals() 和 hashCode() 相关的规则</p></blockquote><h4 id="为什么String、Integer等包装类可以作为key"><a href="#为什么String、Integer等包装类可以作为key" class="headerlink" title="为什么String、Integer等包装类可以作为key"></a>为什么String、Integer等包装类可以作为key</h4><ol><li>String、Integer内部已重写了equals()、hashCode()等方法。</li><li>都是final类型，保证了不可更改性，不会存在获取hash值不同的情况</li></ol><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>在put第①步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">     n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>当第一个线程运行到这后已经拿到了数组数据和长度，如果这时让出CPU，而第二个线程进来后把数组数据改变了，那么当第一线程再次拿到CPU后，继续运行的话，会把第二个线程的数据覆盖掉，造成数据丢失。<br>在put第⑥步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">     resize();</span><br></pre></td></tr></table></figure><p><code>++size</code>并不是原子操作，当多个线程都执行这行代码时，会存在丢失数据的情况。</p><p>来个例子验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger mapSize = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (mapSize.get() &lt; <span class="number">10000</span>)&#123;</span><br><span class="line">            map.put(mapSize.get(),map.get(mapSize));</span><br><span class="line">            mapSize.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashThreadTest hashThreadTest = <span class="keyword">new</span> HashThreadTest();</span><br><span class="line">        Thread[] threads=<span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i]=<span class="keyword">new</span> Thread(hashThreadTest,<span class="string">&quot;线程&quot;</span>+i);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//默认还有个守护线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;map的数量 = &quot;</span>+ hashThreadTest.map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码功能是向map里添加10000条数据，开启5个线程同时操作，运行完后打印的数量并不是10000，说明数据丢失。</p>]]></content>
    
    
    <summary type="html">HashMap 在 Java 中是一个使用高频的数据结构，JDK1.8 以后 HashMap 进行了一次翻天覆地的改变。</summary>
    
    
    
    <category term="JAVA" scheme="http://yaocl.cn/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yaocl.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <link href="http://yaocl.cn/2021/09/28/tcp34/"/>
    <id>http://yaocl.cn/2021/09/28/tcp34/</id>
    <published>2021-09-28T01:53:28.000Z</published>
    <updated>2023-05-22T01:00:59.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义：TCP（Transmission Control Protocol:传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议.</p></blockquote><p>TCP在发送数据前，会在通信双方之间建立一条连接。通过这条连接，客户端和服务端可以保存一份对方的信息，如ip地址、端口号等。通信双方的数据传输就是在这条连接上进行的。这条连接的建立和断开的过程就是所谓的<code>三次握手</code>和<code>四次挥手</code></p><h3 id="TCP报文头部数据"><a href="#TCP报文头部数据" class="headerlink" title="TCP报文头部数据"></a>TCP报文头部数据</h3><p>在了解<code>三次握手</code>和<code>四次挥手</code>之前，先来了解一下TCP报文的头部数据结构<br><img src="/2021/09/28/tcp34/header.png" alt="TCP头部"><br>上图中有几个字段是在<code>三次握手</code>和<code>四次挥手</code>需要的</p><ol><li>Sequence number（seq）：序列号 32位</li><li>Acknowledgment number（ack）: 确认序列号 32位</li><li>SYN、ACK、FIN标志位<ul><li>SYN : 建立起一个新的连接</li><li>ACK ： 确认号有效</li><li>FIN ： 释放一个连接</li></ul></li></ol><p><code>注意： 不要将ack和ACK理解混了，ack是一串序列号，ACK是一个标志位。当ACK为1时，代表ack序列号有效</code></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><code>三次握手</code>是TCP建立连接的过程。主要作用是判断通信双方有没有传输数据的能力。看一下整个握手的过程。<br><img src="/2021/09/28/tcp34/tcp3.png" alt="三次握手"></p><p><code>三次握手</code>步骤：</p><ol><li><p><code>第一次握手</code>：客户端主动向服务端发起一个建立连接的请求。请求数据中</p><ul><li><code>SYN=1</code>表示客户端要与服务端建立一个新的连接</li><li>初始自己的序列号值<code>seq=x</code>  </li></ul><p>此时客户端进入到<code>SYN-SENT</code>状态等待服务器的回复</p></li><li><p><code>第二次握手</code>：服务端收到客户端的请求后，发现<code>SYN=1</code>，知道这是要建立一个连接，于是向客户端发送一个回复消息</p><ul><li>初始自己序列号值<code>seq=y</code></li><li><code>ACK=1</code>表示确认收到了消息</li><li><code>SYN=1</code>表示同意了这次连接，并与客户端建立新连接</li><li><code>ack=x+1</code>客户端发过来的序列号+1  </li></ul><p>此时服务器进入到<code>SYN-RCVD</code>状态</p></li><li><p><code>第三次握手</code>：客户端收到服务端的回复后，发现<code>SYN=1``ACK=1``ack=x+1</code>表示服务端已经收到第一次握手时客户端发送的请求，并同意建立连接，这时，客户端回复一个确认消息</p><ul><li><code>ACK=1</code>表示确认收到了消息、</li><li><code>seq=x+1</code>表示客户端第一次握手x序列号的下一个序列号</li><li><code>ack=y+1</code>表示收到了服务端发动过来的<code>seq=y</code>的消息  </li></ul><p>此时客户端进入到<code>ESTAB-LISHED</code>状态，在服务端收到消息后也进入到<code>ESTAB-LISHED</code>状态。</p></li></ol><p>OK，<code>三次握手</code>完毕，通信双方可以传输数据了</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><code>四次挥手</code>是TCP断开的过程，主要的作用是确保数据已传输完毕，并断开连接，看一下四次挥手的过程<br><img src="/2021/09/28/tcp34/tcp4.png" alt="四次挥手"></p><p><code>四次挥手</code>步骤</p><ol><li><p><code>第一次挥手</code>：客户端主动向服务端发送发断开请求</p><ul><li><code>FIN=1</code>表示释放连接</li><li><code>seq=u</code>客户端当前的序列号</li></ul><p>此时客户端进入到<code>FIN-WAIT-1</code>状态</p></li><li><p><code>第二次挥手</code>：服务端收到客户端发来的请求后，发现<code>FIN=1</code>，知道了这是一个断开请求，然后给客户端发送一个确认请求</p><ul><li><code>ACK=1</code>表示确认收到了客户端释放连接的请求</li><li><code>seq=u</code>服务器当前的序列号</li><li><code>ack=u+1</code>表示服务端收到客户端发来的<code>seq=u</code>的断开请求</li></ul><p>此时服务区进入到<code>CLOSE-WAIT</code>状态，并且不会立即进行第三次挥手，因为这时数据可能还没有传输完成，需要再等待一段时间。<br>客户端在接受到回复后进入到<code>FIN-WAIT-2</code>状态</p></li><li><p><code>第三次挥手</code>：当服务端发送完所有的数据后，主动向客户端发送断开请求</p><ul><li><code>FIN=1</code>表示释放连接</li><li><code>ACK=1、seq=u、ack=u+1</code>和上一次一样  </li></ul><p>此时服务端进入到<code>LAST-ACK</code>状态等待客户端回复</p></li><li><p><code>第四次挥手</code>：客户端收到服务端发来的关闭请求后，向服务端发出确认报文，并进入到<code>TIME-WAIT</code>状态。服务端接受到确认报文后，断开连接，而客户端要等2MSL(最长报文段寿命的2倍时长)后才断开连接，所以服务端结束的时间要比客户端早一些。</p></li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="为什么是3次握手，2次不行么？"><a href="#为什么是3次握手，2次不行么？" class="headerlink" title="为什么是3次握手，2次不行么？"></a>为什么是3次握手，2次不行么？</h4><p>如果是2次握手，假设在第二次握手的时候服务端发送给客户端的消息丢失了，那么这时服务端进入到<code>ESTAB-LISHED</code>状态，准备接收数据了。但是客户端却不知道服务端已经准备好了。那么客户端也不会给服务端发送数据。</p><p>而3次握手多了向服务端最后确认阶段，这样就可以确保客户端已经知道服务端已经准备好了。</p><h4 id="为什么建立连接的时候是3次，断开连接时是4次？"><a href="#为什么建立连接的时候是3次，断开连接时是4次？" class="headerlink" title="为什么建立连接的时候是3次，断开连接时是4次？"></a>为什么建立连接的时候是3次，断开连接时是4次？</h4><p>主要的作用还是确保所有数据已经传输完，第一次挥手客户端主动向服务端发送断开请求表示客户端数据已经传输完毕，第三次挥手服务端主动向客户端发送断开请求表示服务端数据也传输完毕。</p><h4 id="第四次挥手后为什么要等2MSL的时间才断开连接？"><a href="#第四次挥手后为什么要等2MSL的时间才断开连接？" class="headerlink" title="第四次挥手后为什么要等2MSL的时间才断开连接？"></a>第四次挥手后为什么要等2MSL的时间才断开连接？</h4><p>主要是防止第四次挥手客户端的请求丢失，服务端没有接收到客户端最后的确认请求，那么服务端再发送一次第三次挥手的数据，再加上客户端回复确认消息的时间，所以要等待2MSL</p><h4 id="建立连接以后，客户端出现故障怎么办？"><a href="#建立连接以后，客户端出现故障怎么办？" class="headerlink" title="建立连接以后，客户端出现故障怎么办？"></a>建立连接以后，客户端出现故障怎么办？</h4><p>TCP有一个<code>保活机制</code>：<br>在一个时间段内，如果连接没有任何的活动，<code>保活机制</code>会起作用，每隔一个时间间隔，会发送一个报文，如果连续几个报文都没有得到响应，就会认为TCP连接已经死亡，这时系统内核会将错误信息通知给上层应用</p><h4 id="什么是SYN攻击？，如何避免？"><a href="#什么是SYN攻击？，如何避免？" class="headerlink" title="什么是SYN攻击？，如何避免？"></a>什么是SYN攻击？，如何避免？</h4><p>基于第一次握手时，服务器会进入<code>SYN_RCVD</code>状态。攻击者在短时间内伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。</p><p>这本身是TCP设计的原因，SYN攻击不能完全的避免，只能尽可能减少SYN的危害，常见预防方式：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul><li>[1] <a href="https://blog.csdn.net/ThinkWon/article/details/104903925#t11">https://blog.csdn.net/ThinkWon/article/details/104903925#t11</a></li><li>[2] <a href="https://www.cnblogs.com/xiaolincoding/p/12638546.html">https://www.cnblogs.com/xiaolincoding/p/12638546.html</a></li><li>[3] <a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></li></ul>]]></content>
    
    
    <summary type="html">TCP（Transmission Control Protocol:传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议.</summary>
    
    
    
    <category term="计算机网络" scheme="http://yaocl.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yaocl.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
